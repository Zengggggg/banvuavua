<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes" />
  <title>Frame Text Tool</title>
  <link rel="icon" href="Logo.jpg" type="image/x-icon">  
  
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css"
  />
  <!-- Quill Editor -->
  <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
  <script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>
  <style>
    :root{
      /* ===== Brand palette (Red + Beige are primary) ===== */
      --brand-red:        #DC2626;   /* primary red */
      --brand-red-700:    #B91C1C;   /* hover/depth */
      --brand-red-900:    #7F1D1D;   /* strong accent */
      --brand-beige:      #F4E8D8;   /* primary beige (page bg) */
      --brand-beige-200:  #EFE0CC;   /* panels */
      --brand-beige-300:  #E8D6C0;   /* inputs */
      --brand-beige-50:   #FBF6EE;   /* soft highlights */
      --ink:              #1A1A1A;   /* text (secondary color) */
      --border:           rgba(185,28,28,0.25);  /* red-tinted border */
      --border-soft:      rgba(185,28,28,0.15);
      --shadow:           rgba(185,28,28,0.22);
    }

    /* ===== Page layout ===== */
    body{
      background-image: url('background.png');
      margin:0; padding:16px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background:
        radial-gradient(900px 600px at 85% -10%, rgba(220,38,38,0.10), transparent 60%),
        radial-gradient(900px 600px at 0% 110%, rgba(220,38,38,0.08), transparent 60%),
        var(--brand-beige);                /* BEIGE is the main background */
      color: var(--ink);
      min-height:100vh;
      display:flex; flex-direction:column; align-items:center; gap:12px;
      box-sizing:border-box;
    }

    /* Wrap your main two columns if you have them */
    .sidebar{
      width:320px;
      padding:18px;
      border-right:1px solid var(--border-soft);
      background:
        linear-gradient(180deg, var(--brand-beige-50), var(--brand-beige-200));
      display:flex; flex-direction:column; gap:12px;
      box-sizing:border-box;
      border-radius:14px;
      box-shadow: 0 10px 30px var(--shadow);
    }

    .main{
      flex:1;
      display:flex;
      align-items:center; justify-content:center;
      padding:18px; box-sizing:border-box;
    }

    .canvas-wrap{
      padding:16px;
      border-radius:24px;
      background:
        linear-gradient(180deg, var(--brand-beige-50), var(--brand-beige-200));
      border:1px solid var(--border);
      box-shadow: 0 24px 70px var(--shadow);
    }

    canvas{
      display:block;
      width:520px; height:520px;
      border-radius:18px;
      background: var(--brand-beige-50);  /* kh√¥ng c√≤n n·ªÅn ƒëen */
      border:1px solid var(--border-soft);
    }

    /* ===== Typography ===== */
    .tag {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-weight: 600;
      color: var(--brand-red-900);
    }

    .tag i {
      font-size: 1.1em;
      color: var(--brand-red);
    }
    h1{
      margin:0 0 6px 0;
      font-size:18px; font-weight:800;
      color: var(--brand-red);            /* ti√™u ƒë·ªÅ ƒë·ªè */
    }
    p, .status{ margin:0; font-size:12px; color:#6b5346; }

    label{
      font-size:12px; color:#7a5c4b;
      margin-bottom:4px; display:block;
    }

    /* ===== Inputs ===== */
    select, textarea, input[type="text"], input[type="number"]{
      width:100%; padding:8px 10px;
      border-radius:12px;
      border:1px solid var(--border);
      background: var(--brand-beige-300);
      color: var(--ink); font-size:12px;
      outline:none; box-sizing:border-box;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.35);
    }
    input[type="range"]{ width:100%; accent-color: var(--brand-red); }

    select:focus, textarea:focus, input[type="text"]:focus, input[type="number"]:focus, .rte-editor:focus{
      border-color: var(--brand-red-700);
      box-shadow: 0 0 0 3px rgba(220,38,38,0.20);
    }

    .row{ display:flex; gap:8px; align-items:center; justify-content:space-between; }
    .row label{ margin:0; }

    /* ===== Buttons ===== */
    .btn{
      padding:8px 14px; border-radius:999px;
      border:1px solid var(--brand-red-700);
      background: linear-gradient(180deg, var(--brand-red), var(--brand-red-700));
      color: #FFF7F0; font-size:12px; font-weight:800;
      cursor:pointer; display:inline-flex; align-items:center; gap:6px;
      text-transform: uppercase; letter-spacing: .02em;
      box-shadow: 0 12px 28px rgba(220,38,38,0.35);
      transition: transform .15s ease, box-shadow .15s ease, filter .15s ease;
    }
    .btn:hover{
      transform: translateY(-1px);
      box-shadow: 0 16px 36px rgba(220,38,38,0.45);
      filter: brightness(1.05);
    }

    /* ===== Upload (beige primary secondary to red) ===== */
    .upload-wrapper{
      display: flex;
      flex-direction: column;
      gap: 6px;
      align-items: center;        /* <-- cƒÉn gi·ªØa to√†n b·ªô trong wrapper */
      text-align: center;
    }
    .upload-btn{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 14px; border-radius:999px; cursor:pointer;
      border:1px solid var(--border);
      background: var(--brand-beige-50);
      color: var(--ink);
      font-size:12px; font-weight:700;
      box-shadow: 0 6px 14px rgba(220,38,38,0.18);
      transition: transform .15s ease, box-shadow .15s ease, background .15s ease;
    }
    .upload-btn:hover{
      transform: translateY(-1px);
      background: var(--brand-beige);
      box-shadow: 0 10px 22px rgba(220,38,38,0.28);
    }
    .upload-icon{ font-size:14px; }
    .upload-hint{ font-size:11px; color:#7a5c4b; }

    /* ===== Rich Text Editor ===== */
    .rte-toolbar{
      display:flex; align-items:center; gap:6px;
      padding:6px; border:1px solid var(--border);
      border-radius:10px 10px 0 0;
      background: var(--brand-beige-200);
    }
    .rte-btn{
      border:1px solid var(--border);
      background: var(--brand-beige-50);
      color: var(--ink);
      padding:4px 8px; font-size:12px; border-radius:8px; cursor:pointer;
      transition: background .15s ease, color .15s ease, border-color .15s ease;
    }
    .rte-btn:hover{
      background: #FBE9E7;
      border-color: var(--brand-red-700);
      color: var(--brand-red-900);
    }
    .rte-btn-active{
      background: var(--brand-red) !important;
      color: #FFF7F0 !important;
      border-color: var(--brand-red-700) !important;
    }
    .rte-select{
      padding: 4px 8px;
      border: 1px solid var(--border);
      background: var(--brand-beige-50);
      color: var(--ink);
      font-size: 12px;
      border-radius: 8px;
      cursor: pointer;
      outline: none;
      min-width: 90px;
      transition: background .15s ease, border-color .15s ease;
    }
    .rte-select:hover{
      background: #FBE9E7;
      border-color: var(--brand-red-700);
    }
    .rte-select:focus{
      border-color: var(--brand-red-700);
      box-shadow: 0 0 0 2px rgba(220,38,38,0.20);
    }
    .rte-sep{ width:1px; height:18px; background: var(--border); margin:0 2px; }

    .rte-editor{
      min-height:120px; padding:10px 12px;
      border:1px solid var(--border); border-top:none;
      border-radius:0 0 10px 10px;
      background: var(--brand-beige-50);
      color: var(--ink);
      font-size:13px; line-height:1.6; outline:none; white-space:pre-wrap;
    }
    .rte-editor:empty:before{ content:attr(placeholder); color:#967a67; }
    .rte-editor[ data-align="center" ]{ text-align:center; }
    .rte-editor[ data-align="right" ]{ text-align:right; }
    
    /* Quill Editor Styles */
    #quillEditor {
      min-height: 60px;
      max-height: 80px;
      border: 1px solid var(--border);
      border-top: none;
      border-radius: 0 0 10px 10px;
      background: var(--brand-beige-50);
      overflow-y: auto;
      margin-bottom: 12px;
    }
    #quillEditor .ql-editor {
      min-height: 60px;
      max-height: 80px;
      color: var(--ink);
      font-size: 13px;
      line-height: 1.5;
      padding: 6px 10px;
      overflow-y: auto;
    }
    #quillEditor .ql-editor.ql-blank::before {
      content: 'Nh·∫≠p m√¥ t·∫£ / n·ªôi dung...';
      color: #967a67;
      font-style: normal;
      pointer-events: none;
    }
    #quillEditor .ql-container {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }
    #quillEditor .ql-toolbar {
      border: 1px solid var(--border);
      border-bottom: none;
      border-radius: 10px 10px 0 0;
      background: var(--brand-beige-200);
      padding: 4px 6px;
    }
    #quillEditor .ql-toolbar .ql-stroke {
      stroke: var(--ink);
    }
    #quillEditor .ql-toolbar .ql-fill {
      fill: var(--ink);
    }
    #quillEditor .ql-toolbar button:hover,
    #quillEditor .ql-toolbar button.ql-active {
      color: var(--brand-red-900);
    }
    #quillEditor .ql-toolbar button:hover .ql-stroke,
    #quillEditor .ql-toolbar button.ql-active .ql-stroke {
      stroke: var(--brand-red-900);
    }
    #quillEditor .ql-toolbar button:hover .ql-fill,
    #quillEditor .ql-toolbar button.ql-active .ql-fill {
      fill: var(--brand-red-900);
    }

    /* === Layout fix: sidebar tr√°i, canvas ph·∫£i === */
    body{
      display:flex;
      flex-direction: row;           /* <-- ƒë·ªïi t·ª´ column sang row */
      align-items: flex-start;       /* sidebar kh√¥ng b·ªã cƒÉn gi·ªØa theo tr·ª•c d·ªçc */
      gap: 16px;                     /* kho·∫£ng c√°ch gi·ªØa sidebar & main */
      background: url('background2.png');
      flex-wrap: wrap;
    }

    /* Sidebar c·ªë ƒë·ªãnh b·ªÅ r·ªông v√† d√≠nh b√™n tr√°i */
    .sidebar{
      width: 320px;                  /* b·ªÅ r·ªông c·ªôt tr√°i */
      flex: 0 0 320px;               /* kh√¥ng co gi√£n */
      height: calc(100vh - 32px);    /* tr·ª´ padding body 16px tr√™n/d∆∞·ªõi n·∫øu c√≥ */
      position: sticky;              /* d√≠nh khi cu·ªôn */
      top: 16px;
      overflow: auto;                /* cu·ªôn n·ªôi dung n·∫øu d√†i */
      box-sizing: border-box;
      -ms-overflow-style: none;  /* IE/Edge c≈© */
      scrollbar-width: none;     /* Firefox */
    }
    .sidebar::-webkit-scrollbar{ /* Chrome/Safari/Opera */
      width: 0;
      height: 0;
    }

    /* Khu v·ª±c ch√≠nh chi·∫øm ph·∫ßn c√≤n l·∫°i */
    .main{
      flex: 1 1 auto;                /* gi√£n h·∫øt ph·∫ßn c√≤n l·∫°i */
      min-width: 0;                  /* tr√°nh overflow ngang khi c√≥ canvas to */
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* ƒê·∫£m b·∫£o canvas √¥m v·ª´a, kh√¥ng tr√†n */
    .canvas-wrap{
      max-width: 100%;
    }
    canvas{
      max-width: 100%;
      height: auto;
    }

    /* === Responsive: d∆∞·ªõi 900px th√¨ x·∫øp d·ªçc nh∆∞ mobile (sidebar ph√≠a tr√™n l√† OK) === */
    @media (max-width: 900px){
      body{
        flex-direction: column;      /* mobile gi·ªØ d·ªçc */
        align-items: stretch;
      }
      .sidebar{
        position: static;
        width: 100%;
        height: auto;
      }
      .main{
        width: 100%;
        justify-content: center;
      }
    }

    /* ===== Header (ƒë·ªè & be l√† ch·ªß ƒë·∫°o) ===== */
    .app-header{
      flex: 0 0 100%;
      order: -1;
      align-self: stretch;
      width: 100%;
      top: 0; z-index: 1000;
      display: grid;
      grid-template-columns: 1fr auto 1fr; /* tr√°i | gi·ªØa | ph·∫£i */
      align-items: center;
      gap: 12px;

      padding: 10px 14px;
      margin-bottom: 12px;
      border: 1px solid var(--border);
      border-radius: 14px;

      background: linear-gradient(180deg, var(--brand-beige-50), var(--brand-beige-200));
      box-shadow: 0 10px 26px var(--shadow);
    }

    /* C·ªôt tr√°i/gi·ªØa/ph·∫£i */
    .header-left{ display:flex; align-items:center; gap:10px; }
    .header-center{ display:flex; justify-content:center; }
    .header-right{
      display:flex; justify-content:flex-end; align-items:center; gap:10px;
    }

    /* Back link */
    .back-link{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 12px;
      border-radius:999px;
      border:1px solid var(--brand-red-700);
      background: linear-gradient(180deg, var(--brand-red), var(--brand-red-700));
      color:#FFF7F0; text-decoration:none; font-weight:800; font-size:12px;
      box-shadow: 0 8px 20px rgba(220,38,38,.3);
      transition: transform .15s ease, box-shadow .15s ease, filter .15s ease;
    }
    .back-link:hover{
      transform: translateY(-1px); filter: brightness(1.05);
      box-shadow: 0 12px 28px rgba(220,38,38,.4);
    }
    .back-ico{ font-size:14px; line-height:1; }

    /* Ti√™u ƒë·ªÅ trung t√¢m */
    .brand-title{
      margin:0; font-size:14px; font-weight:900; letter-spacing:.02em;
      color: var(--brand-red-900);
    }

    /* N√∫t MXH */
    .social-btn{
      display:inline-flex; align-items:center; justify-content:center;
      width:34px; height:34px; border-radius:10px;
      color: var(--brand-red-900); background: var(--brand-beige-50);
      border:1px solid var(--border);
      transition: transform .15s ease, background .15s ease, color .15s ease;
    }
    .social-btn:hover{
      transform: translateY(-1px);
      background:#FBE9E7; color: var(--brand-red-700);
    }

    /* Responsive: d∆∞·ªõi 900px - Mobile layout d·ªçc */
    @media (max-width: 900px){
      /* Layout d·ªçc: Header -> Sidebar -> Canvas */
      body{
        display: flex;
        flex-direction: column;
        padding: 8px;
        gap: 16px;                           /* TƒÉng gap t·ª´ 8px l√™n 16px */
        min-height: 100dvh;
        background: url('background2.png');
      }

      .app-header{
        position: sticky;
        top: 0;
        z-index: 1000;
        margin-bottom: 0;
        border-radius: 10px;
      }

      .sidebar{
        flex: 0 1 auto;
        width: 100%;
        max-height: 50vh;                    /* Gi·ªõi h·∫°n chi·ªÅu cao ƒë·ªÉ kh√¥ng chi·∫øm h·∫øt m√†n h√¨nh */
        overflow-y: auto;
        overflow-x: hidden;
        padding: 14px;
        border-radius: 12px;
        position: relative;
        -webkit-overflow-scrolling: touch;   /* Smooth scroll tr√™n iOS */
        margin-bottom: 8px;                  /* Th√™m kho·∫£ng c√°ch v·ªõi canvas */
      }

      .sidebar::-webkit-scrollbar{
        width: 6px;
      }

      .sidebar::-webkit-scrollbar-thumb{
        background: var(--brand-red);
        border-radius: 3px;
      }

      /* Main: Canvas area */
      .main{
        flex: 1 1 auto;
        min-height: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 8px;
        overflow: hidden;
      }

      .canvas-wrap{
        width: 100%;
        max-width: 100%;
        padding: 8px;
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      canvas{
        width: 100% !important;
        max-width: 100%;
        height: auto !important;
        touch-action: pan-x pan-y;           /* Cho ph√©p pan/zoom tr√™n mobile */
      }

      /* Typography - d·ªÖ ƒë·ªçc h∆°n */
      h1{
        font-size: 16px;
        margin-bottom: 8px;
      }

      p, .status{
        font-size: 13px;
      }

      label{
        font-size: 14px;
        margin-bottom: 6px;
        font-weight: 600;
      }

      /* Inputs - touch targets l·ªõn h∆°n */
      select, textarea, input[type="text"], input[type="number"]{
        font-size: 16px;                     /* Tr√°nh zoom tr√™n iOS */
        padding: 12px 14px;
        min-height: 44px;                    /* Touch target t·ªëi thi·ªÉu */
        border-radius: 10px;
      }

      input[type="range"]{
        min-height: 44px;
        padding: 8px 0;
      }

      /* Buttons - d·ªÖ b·∫•m h∆°n */
      .btn{
        font-size: 14px;
        padding: 14px 20px;
        min-height: 48px;
        border-radius: 12px;
        width: 100%;
        justify-content: center;
      }

      .upload-btn{
        font-size: 14px;
        padding: 14px 20px;
        min-height: 48px;
        width: 100%;
        justify-content: center;
      }

      /* Rich text editor */
      .rte-toolbar{
        padding: 8px;
        gap: 8px;
        flex-wrap: wrap;
      }

      .rte-btn{
        padding: 10px 14px;
        font-size: 14px;
        min-height: 40px;
        min-width: 40px;
      }

      .rte-select{
        font-size: 14px;
        padding: 10px 12px;
        min-height: 40px;
        min-width: 100px;
      }

      .rte-editor{
        font-size: 16px;                     /* Tr√°nh zoom tr√™n iOS */
        min-height: 120px;
        padding: 12px;
      }

      /* Row layout - stack tr√™n mobile */
      .row{
        flex-direction: column;
        gap: 12px;
      }

      .row > div{
        width: 100%;
      }

      /* Upload wrapper */
      .upload-wrapper{
        gap: 10px;
      }

      .upload-hint{
        font-size: 12px;
      }

      /* Crop controls */
      #cropControls{
        padding-top: 16px;
        gap: 12px;
      }

      #cropControls .row{
        flex-direction: column;
      }

      #resetImageBtn{
        min-height: 48px;
        font-size: 14px;
      }

      /* Status text */
      .status{
        font-size: 12px;
        margin-top: 6px;
      }

      /* Card spacing */
      .card{
        padding: 14px;
        margin-bottom: 12px;
      }

      /* Select dropdown */
      select{
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23DC2626' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 14px center;
        padding-right: 40px;
        appearance: none;
        -webkit-appearance: none;
        -moz-appearance: none;
      }
    }

    /* Mobile nh·ªè h∆°n (d∆∞·ªõi 480px) */
    @media (max-width: 480px){
      body{
        padding: 6px;
        gap: 12px;                           /* TƒÉng gap t·ª´ 6px l√™n 12px */
      }

      .sidebar{
        padding: 12px;
        max-height: 45vh;
        margin-bottom: 6px;                  /* Th√™m kho·∫£ng c√°ch v·ªõi canvas */
      }

      .app-header{
        padding: 6px 8px;
      }

      h1{
        font-size: 15px;
      }

      .btn, .upload-btn{
        padding: 12px 16px;
        font-size: 13px;
      }
    }

    /* Icon-only back button */
    .back-icon{
      display:inline-flex; align-items:center; justify-content:center;
      width: 36px; height: 36px; border-radius: 999px;
      background: var(--brand-beige-50);
      color: var(--brand-red-900);
      border: 1px solid var(--border);
      box-shadow: 0 6px 16px rgba(220,38,38,.18);
      text-decoration: none;
      transition: transform .15s ease, background .15s ease, color .15s ease, box-shadow .15s ease;
    }
    .back-icon:hover{
      transform: translateY(-1px);
      background: #FBE9E7;            /* beige s√°ng h∆°n */
      color: var(--brand-red-700);
      box-shadow: 0 10px 24px rgba(220,38,38,.28);
    }

    /* N·∫øu mu·ªën phi√™n b·∫£n n·ªÅn ƒë·ªè (ƒë·∫≠m h∆°n), b·ªè comment ƒëo·∫°n d∆∞·ªõi v√† thay class .back-icon-red trong HTML */
    
    .back-icon.back-icon-red{
      background: linear-gradient(180deg, var(--brand-red), var(--brand-red-700));
      color: #FFF7F0;
      border-color: var(--brand-red-700);
    }
    .back-icon.back-icon-red:hover{
      filter: brightness(1.05);
    }
    /* --- D·ªãch c√°c icon MXH sang tr√°i --- */
    .header-right {
      justify-content: flex-end;
      gap: 8px;
      margin-right: 60px; /* ho·∫∑c gi·∫£m gi√° tr·ªã n√†y n·∫øu mu·ªën d·ªãch √≠t h∆°n */
      transform: translateX(-8px); /* d·ªãch to√†n b·ªô nh√≥m icon sang tr√°i */
    }

    /* --- N√∫t quay v·ªÅ: hover chuy·ªÉn ƒë·ªè, m≈©i t√™n tr·∫Øng --- */
    .back-icon {
      background: var(--brand-beige-50);
      color: var(--brand-red-900);
      border: 1px solid var(--border);
      box-shadow: 0 6px 16px rgba(220,38,38,.18);
      transition: transform .15s ease, background .15s ease, color .15s ease, box-shadow .15s ease;
    }

    .back-icon:hover {
      background: var(--brand-red); /* chuy·ªÉn n·ªÅn sang ƒë·ªè */
      color: white; /* m≈©i t√™n chuy·ªÉn tr·∫Øng */
      box-shadow: 0 10px 24px rgba(220,38,38,.35);
      transform: translateY(-1px);
    }

    /* Mobile nh·ªè h∆°n (d∆∞·ªõi 480px) */
    @media (max-width: 480px){
      body{
        padding: 6px;
        gap: 12px;                           /* TƒÉng gap t·ª´ 6px l√™n 12px */
      }

      .sidebar{
        padding: 12px;
        max-height: 45vh;
        margin-bottom: 6px;                  /* Th√™m kho·∫£ng c√°ch v·ªõi canvas */
      }

      .app-header{
        padding: 6px 8px;
      }

      h1{
        font-size: 15px;
      }

      .btn, .upload-btn{
        padding: 12px 16px;
        font-size: 13px;
      }
    }


    /* Icon-only back button */
    .back-icon{
      display:inline-flex; align-items:center; justify-content:center;
      width: 36px; height: 36px; border-radius: 999px;
      background: var(--brand-beige-50);
      color: var(--brand-red-900);
      border: 1px solid var(--border);
      box-shadow: 0 6px 16px rgba(220,38,38,.18);
      text-decoration: none;
      transition: transform .15s ease, background .15s ease, color .15s ease, box-shadow .15s ease;
    }
    .back-icon:hover{
      transform: translateY(-1px);
      background: #FBE9E7;            /* beige s√°ng h∆°n */
      color: var(--brand-red-700);
      box-shadow: 0 10px 24px rgba(220,38,38,.28);
    }

    /* N·∫øu mu·ªën phi√™n b·∫£n n·ªÅn ƒë·ªè (ƒë·∫≠m h∆°n), b·ªè comment ƒëo·∫°n d∆∞·ªõi v√† thay class .back-icon-red trong HTML */
    
    .back-icon.back-icon-red{
      background: linear-gradient(180deg, var(--brand-red), var(--brand-red-700));
      color: #FFF7F0;
      border-color: var(--brand-red-700);
    }
    .back-icon.back-icon-red:hover{
      filter: brightness(1.05);
    }
    /* --- D·ªãch c√°c icon MXH sang tr√°i --- */
    .header-right {
      justify-content: flex-end;
      gap: 8px;
      margin-right: 60px; /* ho·∫∑c gi·∫£m gi√° tr·ªã n√†y n·∫øu mu·ªën d·ªãch √≠t h∆°n */
      transform: translateX(-8px); /* d·ªãch to√†n b·ªô nh√≥m icon sang tr√°i */
    }

    /* --- N√∫t quay v·ªÅ: hover chuy·ªÉn ƒë·ªè, m≈©i t√™n tr·∫Øng --- */
    .back-icon {
      background: var(--brand-beige-50);
      color: var(--brand-red-900);
      border: 1px solid var(--border);
      box-shadow: 0 6px 16px rgba(220,38,38,.18);
      transition: transform .15s ease, background .15s ease, color .15s ease, box-shadow .15s ease;
    }

    .back-icon:hover {
      background: var(--brand-red); /* chuy·ªÉn n·ªÅn sang ƒë·ªè */
      color: white; /* m≈©i t√™n chuy·ªÉn tr·∫Øng */
      box-shadow: 0 10px 24px rgba(220,38,38,.35);
      transform: translateY(-1px);
    }

   


  
  </style>


</head>
<body>
  <header class="app-header">
    <div class="header-left">
      <a class="back-icon" href="/template-select.html" title="Quay l·∫°i trang ch·ªçn template" aria-label="Quay l·∫°i trang ch·ªçn template">
        <!-- Arrow Left -->
        <svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true">
          <path fill="currentColor" d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2Z"/>
        </svg>
      </a>
    </div>

    <div class="header-center">
      <h1 class="brand-title"></h1>
    </div>

    <nav class="header-right" aria-label="Social links">
      <a class="social-btn" href="https://www.facebook.com/banstudioHN" target="_blank" rel="noopener">
        <!-- Facebook -->
        <svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true">
          <path fill="currentColor" d="M22 12.07C22 6.48 17.52 2 11.93 2S2 6.48 2 12.07c0 5.02 3.66 9.18 8.44 9.93v-7.03H7.9v-2.9h2.54V9.41c0-2.5 1.49-3.88 3.77-3.88 1.09 0 2.23.2 2.23.2v2.45h-1.26c-1.24 0-1.62.77-1.62 1.56v1.87h2.76l-.44 2.9h-2.32V22c4.78-.75 8.44-4.91 8.44-9.93Z"/>
        </svg>
      </a>
      <a class="social-btn" href="https://www.instagram.com/banvaii/" target="_blank" rel="noopener">
        <!-- Instagram -->
        <svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true">
          <path fill="currentColor" d="M7 2h10a5 5 0 0 1 5 5v10a5 5 0 0 1-5 5H7a5 5 0 0 1-5-5V7a5 5 0 0 1 5-5Zm0 2a3 3 0 0 0-3 3v10a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3V7a3 3 0 0 0-3-3H7Zm5 3.5A5.5 5.5 0 1 1 6.5 13 5.5 5.5 0 0 1 12 7.5Zm0 2A3.5 3.5 0 1 0 15.5 13 3.5 3.5 0 0 0 12 9.5ZM18 6.2a1 1 0 1 0 1 1 1 1 0 0 0-1-1Z"/>
        </svg>
      </a>
      <a class="social-btn" href="https://www.tiktok.com/@aobanvai" target="_blank" rel="noopener">
        <!-- TikTok -->
        <svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true">
          <path fill="currentColor" d="M14.5 3.1v8.2a3.9 3.9 0 1 1-3.9-3.9c.2 0 .5 0 .7.1V5.06a7.02 7.02 0 0 0-.7-.04A6.94 6.94 0 1 0 17.54 12V9.58a7.2 7.2 0 0 0 4.46 1.52V8.1a4.7 4.7 0 0 1-4.46-5Z"/>
        </svg>
      </a>
    </nav>
  </header>

  <div class="sidebar">
    <div>
      <h1>Frame Text Tool</h1>
      <p>Ch·ªçn frame, nh·∫≠p n·ªôi dung, ch·ªçn ·∫£nh. V·ªã tr√≠ khung ƒë√£ ƒë∆∞·ª£c c·ªë ƒë·ªãnh.</p>
    </div>

    <div>
      <label>Ch·ªçn frame</label>
      <select id="frameSelect"></select>
      <div class="status" id="statusText">ƒêang t·∫£i danh s√°ch frame...</div>
    </div>

    <!-- Thay th·∫ø nguy√™n kh·ªëi: label + Quill editor -->
    <div style="margin-bottom: 12px;">
      <label>N·ªôi dung text</label>

      <!-- Font Size Dropdown (b√™n ngo√†i Quill toolbar) -->
      <div style="margin-bottom: 8px;">
        <select id="fontSizeSelect" class="font-size-select-standalone" style="padding: 4px 8px; border: 1px solid var(--border); background: var(--brand-beige-50); color: var(--ink); font-size: 12px; border-radius: 8px; cursor: pointer; outline: none; min-width: 90px; height: 28px;">
          <option value="">C·ª° ch·ªØ</option>
          <option value="12px">12px</option>
          <option value="14px">14px</option>
          <option value="16px">16px</option>
          <option value="18px">18px</option>
          <option value="20px">20px</option>
          <option value="24px">24px</option>
          <option value="28px">28px</option>
          <option value="32px">32px</option>
          <option value="36px">36px</option>
          <option value="48px">48px</option>
          <option value="60px">60px</option>
          <option value="72px">72px</option> 
        </select>
      </div>

      <!-- Quill Editor -->
      <div id="quillEditor"></div>
      <!-- (T√πy ch·ªçn) ·∫®n textarea c≈© ƒë·ªÉ gi·ªØ compatibility -->
      <textarea id="textInput" style="display:none;"></textarea>
    </div>


    <div class="row">
      <div style="flex:1">
        <label>Gi√£n d√≤ng</label>
        <input id="lineHeight" type="number" step="0.1" min="0.8" max="2.0" value="1.2" />
      </div>
      <div style="flex:1">
        <label>Padding (px)</label>
        <input id="padding" type="number" min="0" max="80" value="10" />
      </div>
    </div>

    <div class="row">
      <div style="flex:1">
        <label>K√≠ch th∆∞·ªõc xu·∫•t (px)</label>
        <input id="exportSize" type="number" min="600" max="2000" step="60" value="1080" />
      </div>
      <div style="flex:1">
        <label>Zoom xem tr∆∞·ªõc (<span id="zoomLabel">70</span>%)</label>
        <input id="previewZoom" type="range" min="30" max="120" step="5" value="70" />
      </div>
    </div>
    
    <div class="upload-wrapper">
      <label>·∫¢nh c·ªßa b·∫°n</label>
      <button type="button" id="overlayToggleBtn" class="upload-btn">
        <span id="overlayBtnText">
          <i class="bi bi-camera-fill"></i> Ch·ªçn ·∫£nh
        </span>
      </button>

      <input id="overlayInput" type="file" accept="image/*" style="display:none" />
      <div class="upload-hint">PNG/JPG ‚Ä¢ S·∫Ω t·ª± cƒÉn v√†o khung ·∫£nh ƒë√£ thi·∫øt k·∫ø.</div>
    </div>

    <!-- Crop/Pan Controls -->
    <div id="cropControls" style="display:none; border-top:1px solid var(--border-soft); padding-top:12px; gap:8px; display:flex; flex-direction:column;">
      <div class="row">
        <div style="flex:1">
          <label>Zoom ·∫£nh (<span id="zoomImageLabel">100</span>%)</label>
          <input id="imageZoom" type="range" min="50" max="200" step="10" value="100" />
        </div>
      </div>
      <button type="button" id="resetImageBtn" class="btn" style="margin:0; width:100%; font-size:11px; padding:6px 10px;">
        <i class="bi bi-arrow-counterclockwise"></i> ƒê·∫∑t l·∫°i
      </button>
      <div style="font-size:11px; color:#7a5c4b; text-align:center;">
        üí° K√©o ·∫£nh tr√™n khung ƒë·ªÉ ƒëi·ªÅu ch·ªânh v·ªã tr√≠
      </div>
    </div>



    <button
      class="btn"
      id="downloadBtn"
      style="
        font-family:-apple-system,'Segoe UI',Tahoma,'Helvetica Neue',Arial,'DejaVu Sans',Ubuntu,Cantarell,'Noto Sans',sans-serif;
        font-weight:700; letter-spacing:.02em;
        display:block;            /* ƒë·ªÉ margin auto c√≥ t√°c d·ª•ng */
        margin:8px auto 0;        /* cƒÉn gi·ªØa ngang */
        text-align:center;        /* cƒÉn gi·ªØa n·ªôi dung */
        align-self:center;        /* n·∫øu parent l√† flex th√¨ v·∫´n gi·ªØa */
      "
    >
      <i class="bi bi-download"></i> Xu·∫•t ·∫£nh PNG
    </button>

  </div>

  <div class="main">
    <div class="canvas-wrap">
      <canvas id="canvas" width="1080" height="1080"></canvas>
    </div>
  </div>

<script>
  // ================= CONFIG =================
  const API_BASE = "/api/frame-layout"; // relative: ch·∫°y ƒë∆∞·ª£c c·∫£ localhost & ngrok
  const BASE_SIZE = 1080;
  const DEFAULT_OVERLAY_RADIUS = 20;
  const DEFAULT_OVERLAY_ALPHA = 1;
  const FIT_MODE = "cover";

  // ================= DOM =================
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");

  const frameSelect = document.getElementById("frameSelect");
  const statusText = document.getElementById("statusText");

  const textInput = document.getElementById("textInput");
  const lineHeightEl = document.getElementById("lineHeight");
  const paddingEl = document.getElementById("padding");
  const exportSizeEl = document.getElementById("exportSize");
  const previewZoomEl = document.getElementById("previewZoom");
  const zoomLabel = document.getElementById("zoomLabel");

  const overlayInput = document.getElementById("overlayInput");
  const overlayToggleBtn = document.getElementById("overlayToggleBtn");
  const overlayBtnText = document.getElementById("overlayBtnText");
  const overlayBtnIcon = document.getElementById("overlayBtnIcon");

  const downloadBtn = document.getElementById("downloadBtn");
  
  // Kh·ªüi t·∫°o Quill Editor
  let quill = null;
  const quillEditor = document.getElementById("quillEditor");
  if (quillEditor) {
    // T·∫°o custom format cho font size (pixel) s·ª≠ d·ª•ng inline style
    const Parchment = Quill.import('parchment');
    const FontSizeStyle = new Parchment.Attributor.Style('fontSize', 'font-size', {
      scope: Parchment.Scope.INLINE,
      whitelist: ['12px', '14px', '16px', '18px', '20px', '24px', '28px', '32px', '36px', '48px', '60px', '72px']
    });
    Quill.register(FontSizeStyle, true);

    quill = new Quill('#quillEditor', {
      theme: 'snow',
      placeholder: 'Nh·∫≠p m√¥ t·∫£ / n·ªôi dung...',
      modules: {
        toolbar: [
          ['bold', 'italic'],
          [{ 'align': [] }],
          [{ 'list': 'ordered'}, { 'list': 'bullet' }]
        ]
      }
    });
    
    // K·∫øt n·ªëi dropdown font size v·ªõi Quill
    const fontSizeSelect = document.getElementById('fontSizeSelect');
    if (fontSizeSelect) {
      // X·ª≠ l√Ω khi ch·ªçn c·ª° ch·ªØ
      fontSizeSelect.addEventListener('change', function() {
        const value = this.value;
        if (value) {
          quill.format('fontSize', value);
        } else {
          quill.format('fontSize', false);
        }
      });
      
      // C·∫≠p nh·∫≠t dropdown khi selection thay ƒë·ªïi
      quill.on('selection-change', function(range) {
        if (range && fontSizeSelect) {
          const format = quill.getFormat(range);
          if (format.fontSize) {
            fontSizeSelect.value = format.fontSize;
          } else {
            fontSizeSelect.value = '';
          }
        }
      });
    }
    
    // L·∫Øng nghe thay ƒë·ªïi ƒë·ªÉ re-render canvas
    quill.on('text-change', () => {
      sizeChange();
    });
  }

  const imageZoomEl = document.getElementById("imageZoom");
  const zoomImageLabel = document.getElementById("zoomImageLabel");
  const cropControls = document.getElementById("cropControls");
  const resetImageBtn = document.getElementById("resetImageBtn");

  // ================= STATE =================
  let frames = [];
  let currentKey = null;
  let currentLayout = null; // { frame_url, textBox, imageBox, colors... }

  let frameImg = new Image();
  let frameLoaded = false;
  let layoutLoaded = false;

  let overlayImg = null;
  let hasOverlay = false;
  // --- Th√™m bi·∫øn tr·∫°ng th√°i cho ·∫£nh Overlay ---
  let overlayZoom = 1.0;          // T·ªâ l·ªá zoom c·ªßa ·∫£nh g·ªëc (1.0 = fit)
  let overlayOffsetX = 0;         // D·ªãch chuy·ªÉn X (px)
  let overlayOffsetY = 0;         // D·ªãch chuy·ªÉn Y (px)
  // ------------------------------------------
  

  // ================= HELPERS =================
  function setStatus(msg, error = false) {
    if (!statusText) return;
    statusText.textContent = msg;
    statusText.style.color = error ? "#f97316" : "#6b7280";
  }

  function safeAddListener(el, ev, fn) {
    if (el) el.addEventListener(ev, fn);
  }

  function boxPercentToPx(box, size) {
    return {
      x: (box.x / 100) * size,
      y: (box.y / 100) * size,
      w: (box.w / 100) * size,
      h: (box.h / 100) * size,
    };
  }

  // ===== Quill Editor Functions =====
  function getEditorAlign() {
    if (!quill) return 'left';
    const format = quill.getFormat();
    return format.align || 'left';
  }

  function getEditorPlainText() {
    if (!quill) return "";
    return quill.getText().replace(/\r/g, "");
  }

  // Tr·∫£ v·ªÅ [{ tokens:[{type:'text'|'bold'|'italic', text:'...'}], listType:'bullet'|'ordered'|null, listNumber?:number }]
  function serializeEditorToLines() {
    if (!quill) return [{ tokens: [{ type: 'text', text: '' }], listType: null }];

    // Parse t·ª´ HTML c·ªßa Quill - ƒë∆°n gi·∫£n v√† ch√≠nh x√°c h∆°n
    const html = quill.root.innerHTML;
    if (!html || html.trim() === '') {
      return [{ tokens: [{ type: 'text', text: '' }], listType: null }];
    }

    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = html;
    const lines = [];
    let orderedListCounter = 0;

    // H√†m extract tokens t·ª´ m·ªôt node (h·ªó tr·ª£ bold/italic/fontSize)
    function extractTokensFromNode(node) {
      const tokens = [];
      
      function walk(n, styleCtx) {
        styleCtx = styleCtx || { bold: false, italic: false, fontSize: null };
        
        if (n.nodeType === Node.TEXT_NODE) {
          const text = n.textContent || '';
          if (text.length > 0) {
            let type = 'text';
            if (styleCtx.bold && styleCtx.italic) {
              type = 'bold'; // ∆Øu ti√™n bold
            } else if (styleCtx.bold) {
              type = 'bold';
            } else if (styleCtx.italic) {
              type = 'italic';
            }
            
            tokens.push({ 
              type, 
              text,
              size: styleCtx.fontSize || null
            });
          }
          return;
        }
        
        if (n.nodeType === Node.ELEMENT_NODE) {
          const tag = n.tagName?.toLowerCase();
          const nextCtx = { ...styleCtx };
          
          if (tag === 'b' || tag === 'strong') nextCtx.bold = true;
          if (tag === 'i' || tag === 'em') nextCtx.italic = true;
          
          // Ki·ªÉm tra fontSize t·ª´ style
          if (n.style && n.style.fontSize) {
            nextCtx.fontSize = n.style.fontSize;
          }
          
          Array.from(n.childNodes).forEach(child => walk(child, nextCtx));
        }
      }
      
      walk(node, { bold: false, italic: false, fontSize: null });
      return tokens.length > 0 ? tokens : [{ type: 'text', text: '' }];
    }

    // X·ª≠ l√Ω c√°c node con
    Array.from(tempDiv.childNodes).forEach(node => {
      if (node.nodeType === Node.ELEMENT_NODE) {
        const tag = node.tagName?.toLowerCase();
        
        if (tag === 'ol') {
          // Ordered list
          orderedListCounter = 0;
          Array.from(node.querySelectorAll('li')).forEach(li => {
            orderedListCounter++;
            const tokens = extractTokensFromNode(li);
            lines.push({ 
              tokens, 
              listType: 'ordered',
              listNumber: orderedListCounter
            });
          });
        } else if (tag === 'ul') {
          // Bullet list
          orderedListCounter = 0;
          Array.from(node.querySelectorAll('li')).forEach(li => {
            const tokens = extractTokensFromNode(li);
            lines.push({ 
              tokens, 
              listType: 'bullet'
            });
          });
        } else if (tag === 'p' || tag === 'div') {
          // Paragraph ho·∫∑c div - c√≥ th·ªÉ ch·ª©a nhi·ªÅu d√≤ng (br)
          const parts = [];
          let current = [];
          
          function splitByBr(el) {
            const result = [];
            let currentPart = [];
            
            function processNode(n) {
              if (n.nodeType === Node.TEXT_NODE) {
                const text = n.textContent || '';
                if (text.includes('\n')) {
                  const textParts = text.split('\n');
                  for (let i = 0; i < textParts.length; i++) {
                    if (textParts[i].length > 0) {
                      currentPart.push({ type: 'text', text: textParts[i] });
                    }
                    if (i < textParts.length - 1) {
                      result.push([...currentPart]);
                      currentPart = [];
                    }
                  }
                } else if (text.length > 0) {
                  currentPart.push({ type: 'text', text });
                }
              } else if (n.nodeType === Node.ELEMENT_NODE) {
                if (n.tagName?.toLowerCase() === 'br') {
                  result.push([...currentPart]);
                  currentPart = [];
                } else {
                  const tokens = extractTokensFromNode(n);
                  currentPart.push(...tokens);
                }
              }
            }
            
            Array.from(el.childNodes).forEach(processNode);
            if (currentPart.length > 0) {
              result.push(currentPart);
            }
            
            return result.length > 0 ? result : [[]];
          }
          
          const lineParts = splitByBr(node);
          lineParts.forEach(partTokens => {
            if (partTokens.length > 0 || lineParts.length === 1) {
              lines.push({ 
                tokens: partTokens.length > 0 ? partTokens : [{ type: 'text', text: '' }], 
                listType: null 
              });
            }
          });
        } else if (tag === 'br') {
          // Line break
          lines.push({ tokens: [{ type: 'text', text: '' }], listType: null });
        } else {
          // Inline element
          const tokens = extractTokensFromNode(node);
          if (tokens.length > 0) {
            lines.push({ tokens, listType: null });
          }
        }
      } else if (node.nodeType === Node.TEXT_NODE) {
        const text = node.textContent || '';
        if (text.trim() || text.includes('\n')) {
          const parts = text.split('\n');
          parts.forEach((part, idx) => {
            if (part.trim() || idx < parts.length - 1) {
              lines.push({ 
                tokens: [{ type: 'text', text: part }], 
                listType: null 
              });
            }
          });
        }
      }
    });

    if (!lines.length) {
      lines.push({ tokens: [{ type: 'text', text: '' }], listType: null });
    }

    return lines;
  }


  // Helper: chuy·ªÉn ƒë·ªïi size t·ª´ Quill format (px string) sang s·ªë pixel
  function getFontSizeFromToken(token, baseFontPx) {
    if (!token.size) return baseFontPx;
    // token.size c√≥ th·ªÉ l√† "12px", "24px", etc.
    const sizeStr = String(token.size);
    const sizeNum = parseInt(sizeStr.replace('px', ''), 10);
    if (!isNaN(sizeNum) && sizeNum > 0) {
      return sizeNum;
    }
    return baseFontPx;
  }

  // ƒêo t·ªïng width c·ªßa 1 d√≤ng token v·ªõi base fontPx
  function measureTokensWidth(ctx, tokens, fontPx) {
    let w = 0;
    tokens.forEach(tk => {
      const fontStyle = tk.type === 'italic' ? 'italic' : 'normal';
      const fontWeight = tk.type === 'bold' ? '700' : '400';
      const actualFontPx = getFontSizeFromToken(tk, fontPx);
      ctx.font = `${fontStyle} ${fontWeight} ${actualFontPx}px system-ui, -apple-system, sans-serif`;
      w += ctx.measureText(tk.text).width;
    });
    return w;
  }

  // V·∫Ω 1 d√≤ng token theo (x, y)
  function drawTokensLine(ctx, tokens, x, y, fontPx, color) {
    let cursor = x;
    
    // T√¨m font size l·ªõn nh·∫•t trong d√≤ng ƒë·ªÉ cƒÉn baseline
    let maxFontPx = fontPx;
    tokens.forEach(tk => {
      const actualFontPx = getFontSizeFromToken(tk, fontPx);
      if (actualFontPx > maxFontPx) maxFontPx = actualFontPx;
    });
    
    tokens.forEach(tk => {
      const fontStyle = tk.type === 'italic' ? 'italic' : 'normal';
      const fontWeight = tk.type === 'bold' ? '700' : '400';
      const actualFontPx = getFontSizeFromToken(tk, fontPx);
      ctx.font = `${fontStyle} ${fontWeight} ${actualFontPx}px system-ui, -apple-system, sans-serif`;
      ctx.fillStyle = color;
      if (tk.text) {
        // CƒÉn baseline: c√°c c·ª° ch·ªØ nh·ªè h∆°n s·∫Ω ƒë∆∞·ª£c ƒë·∫©y xu·ªëng ƒë·ªÉ align v·ªõi c·ª° ch·ªØ l·ªõn nh·∫•t
        const baselineOffset = (maxFontPx - actualFontPx) * 0.2; // ƒêi·ªÅu ch·ªânh nh·∫π ƒë·ªÉ ƒë·∫πp h∆°n
        ctx.fillText(tk.text, cursor, y + baselineOffset);
        cursor += ctx.measureText(tk.text).width;
      }
    });
  }

  // Sync khi g√µ: re-render (ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω trong Quill text-change event)

  // ===== Wrap & fit =====
  function wrapLines(ctx, text, maxWidth) {
    const lines = [];
    const paragraphs = text.split("\n");

    for (const para of paragraphs) {
      if (para === "") {
        lines.push("");
        continue;
      }
      const words = para.split(/\s+/);
      let line = "";
      for (const w of words) {
        if (!w) continue;
        const test = line ? line + " " + w : w;
        if (ctx.measureText(test).width <= maxWidth) {
          line = test;
        } else {
          if (line) lines.push(line);
          line = w;
        }
      }
      if (line) lines.push(line);
    }
    return lines;
  }

  function computeFittedLines(text, boxPx, padding, lineH) {
    let fontPx = 20;
    const maxHeight = boxPx.h - padding * 2;
    let lines = [];

    while (fontPx >= 10) {
      ctx.font = `normal 400 ${fontPx}px system-ui, -apple-system, sans-serif`;
      const maxWidth = Math.max(0, boxPx.w - padding * 2);
      lines = wrapLines(ctx, text, maxWidth);

      const lh = lineH * fontPx;
      const totalH = lines.length * lh;

      if (totalH <= maxHeight) {
        return { fontPx, lines, lh };
      }
      fontPx--;
    }

    ctx.font = "normal 400 10px system-ui, -apple-system, sans-serif";
    const maxWidth = Math.max(0, boxPx.w - padding * 2);
    lines = wrapLines(ctx, text, maxWidth);
    return { fontPx: 10, lines, lh: lineH * 10 };
  }

  function drawRoundedRectPath(ctx, x, y, w, h, r) {
    const rr = Math.min(r, w / 2, h / 2);
    ctx.beginPath();
    ctx.moveTo(x + rr, y);
    ctx.arcTo(x + w, y, x + w, y + h, rr);
    ctx.arcTo(x + w, y + h, x, y + h, rr);
    ctx.arcTo(x, y + h, x, y, rr);
    ctx.arcTo(x, y, x + w, y, rr);
    ctx.closePath();
  }

  function updateOverlayButton() {
    if (!overlayToggleBtn || !overlayBtnText) return;

    if (hasOverlay) {
      overlayBtnText.innerHTML = '<i class="bi bi-x-lg"></i> G·ª° ·∫£nh';
      overlayToggleBtn.style.background = "linear-gradient(180deg, var(--brand-red), var(--brand-red-700))";
      overlayToggleBtn.style.color = "#fff";
      
      // Hi·ªÉn th·ªã crop controls
      if (cropControls) cropControls.style.display = "block";
    } else {
      overlayBtnText.innerHTML = '<i class="bi bi-camera-fill"></i> Ch·ªçn ·∫£nh';
      overlayToggleBtn.style.background = "var(--brand-beige-50)";
      overlayToggleBtn.style.color = "var(--brand-red-900)";
      
      // ·∫®n crop controls
      if (cropControls) cropControls.style.display = "none";
    }
  }

  // ================= RENDER =================
  function render(targetSize = BASE_SIZE, opts = {}) {
    if (!frameLoaded || !layoutLoaded || !currentLayout) return;

    const { forceHideBox = false } = opts;

    const textColor      = currentLayout.textColor        || "#333333";
    const imgBorderColor = currentLayout.imageBorderColor || "#000000";
    const textBoxColor   = currentLayout.textBoxColor     || "#22c55e";
    const imageBoxColor  = currentLayout.imageBoxColor    || "#38bdf8";

    const DPR = window.devicePixelRatio || 1;
    canvas.width = targetSize * DPR;
    canvas.height = targetSize * DPR;

    const zoom = parseInt(previewZoomEl?.value || "70", 10) / 100;
    canvas.style.width = targetSize * zoom + "px";
    canvas.style.height = "auto";

    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    ctx.clearRect(0, 0, targetSize, targetSize);

    // V·∫Ω frame (cover)
    const ir = frameImg.width / frameImg.height || 1;
    let w, h, x, y;
    if (ir > 1) {
      h = targetSize;
      w = h * ir;
      x = -(w - targetSize) / 2;
      y = 0;
    } else {
      w = targetSize;
      h = w / ir;
      x = 0;
      y = -(h - targetSize) / 2;
    }
    ctx.drawImage(frameImg, x, y, w, h);

    const textPx = boxPercentToPx(currentLayout.textBox, targetSize);
    const imagePx = boxPercentToPx(currentLayout.imageBox, targetSize);

    // ·∫¢nh overlay trong khung
    const rad = DEFAULT_OVERLAY_RADIUS;

    ctx.save();
    drawRoundedRectPath(ctx, imagePx.x, imagePx.y, imagePx.w, imagePx.h, rad);
    ctx.clip();

    // n·ªÅn tr·∫Øng m·∫∑c ƒë·ªãnh
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(imagePx.x, imagePx.y, imagePx.w, imagePx.h);

    if (overlayImg && hasOverlay) {
      // T√≠nh k√≠ch th∆∞·ªõc g·ªëc c·ªßa ·∫£nh d√πng cover mode (·∫£nh ph·ªß ƒë·∫ßy khung)
      const ir2 = overlayImg.width / overlayImg.height;
      const br = imagePx.w / imagePx.h;
      let initialW, initialH, initialX, initialY;

      if (ir2 > br) { // ·∫£nh r·ªông h∆°n khung
        initialH = imagePx.h;
        initialW = initialH * ir2;
        initialX = imagePx.x - (initialW - imagePx.w) / 2;
        initialY = imagePx.y;
      } else { // ·∫£nh cao h∆°n khung
        initialW = imagePx.w;
        initialH = initialW / ir2;
        initialX = imagePx.x;
        initialY = imagePx.y - (initialH - imagePx.h) / 2;
      }

      // √Åp d·ª•ng zoom (ph√≥ng to/thu nh·ªè t·ª´ t√¢m)
      const zoomedW = initialW * overlayZoom;
      const zoomedH = initialH * overlayZoom;
      const zoomCenterX = initialX + initialW / 2;
      const zoomCenterY = initialY + initialH / 2;

      // V·∫Ω ·∫£nh v·ªõi zoom v√† pan (k√©o)
      const drawX = zoomCenterX - zoomedW / 2 + overlayOffsetX;
      const drawY = zoomCenterY - zoomedH / 2 + overlayOffsetY;

      ctx.globalAlpha = DEFAULT_OVERLAY_ALPHA;
      ctx.drawImage(overlayImg, drawX, drawY, zoomedW, zoomedH);
    }

    ctx.restore();

    // vi·ªÅn khung ·∫£nh
    ctx.save();
    drawRoundedRectPath(ctx, imagePx.x, imagePx.y, imagePx.w, imagePx.h, rad);
    ctx.lineWidth = 6;
    ctx.strokeStyle = imgBorderColor;
    ctx.stroke();
    ctx.restore();

    // KHUNG DEBUG (t·∫Øt m·∫∑c ƒë·ªãnh)
    const showNow = false;
    if (showNow && !forceHideBox) {
      ctx.save();
      ctx.setLineDash([8, 6]);
      ctx.lineWidth = 2.5;

      ctx.strokeStyle = textBoxColor;
      ctx.strokeRect(textPx.x, textPx.y, textPx.w, textPx.h);

      ctx.strokeStyle = imageBoxColor;
      ctx.strokeRect(imagePx.x, imagePx.y, imagePx.w, imagePx.h);

      ctx.setLineDash([]);
      ctx.restore();
    }

    // ===== V·∫Ω text c√≥ inline style & align & bullet =====
    const padding = parseFloat(paddingEl?.value) || 0;

    let rawLH = parseFloat(lineHeightEl?.value);
    if (isNaN(rawLH)) rawLH = 1.0;
    const lineH = Math.max(0.8, rawLH);

    // L·∫•y lines t·ª´ HTML editor (g·ªìm tokens & c·ªù bullet)
    const richLines = serializeEditorToLines();

    // D√πng text plain ƒë·ªÉ ∆∞·ªõc l∆∞·ª£ng fontPx & line height ph√π h·ª£p khung
    const plain = richLines.map(r => r.tokens.map(t => t.text).join('')).join('\n');
    const fit = computeFittedLines(plain, textPx, padding, lineH);

    ctx.textBaseline = "top";
    ctx.fillStyle = currentLayout.textColor || "#333";

    const innerLeft = textPx.x + padding;
    const innerRight = textPx.x + textPx.w - padding;
    const innerWidth = innerRight - innerLeft;

    let ty = textPx.y + padding;
    const align = getEditorAlign();

    let orderedListCounter = 0; // ƒê·∫øm s·ªë th·ª© t·ª± cho ordered list
    
    for (const row of richLines) {
      // X√°c ƒë·ªãnh lo·∫°i list
      const isBullet = row.listType === 'bullet';
      const isOrdered = row.listType === 'ordered';
      const hasList = isBullet || isOrdered;
      
      // H·ªó tr·ª£ c·∫£ 2 ki·ªÉu bullet: t·ª´ <li> ho·∫∑c t·ª´ k√Ω t·ª± '‚Ä¢ ' ƒë·∫ßu d√≤ng
      let detectedBullet = false;
      if (!hasList && row.tokens.length && typeof row.tokens[0].text === 'string' && /^\s*‚Ä¢\s+/.test(row.tokens[0].text)) {
        row.tokens[0].text = row.tokens[0].text.replace(/^\s*‚Ä¢\s+/, '');
        detectedBullet = true;
      }
      const finalIsBullet = isBullet || detectedBullet;
      
      // T√≠nh indent v√† gap
      const listIndent = hasList ? Math.min(20, fit.fontPx * 1.2) : 0;
      const listGap = hasList ? Math.min(10, fit.fontPx * 0.5) : 0;

      // ƒêo width d√≤ng theo tokens ƒë·ªÉ canh l·ªÅ
      const tokensWidth = measureTokensWidth(ctx, row.tokens, fit.fontPx);
      let listMarkerWidth = 0;
      if (isOrdered && row.listNumber) {
        // ∆Ø·ªõc l∆∞·ª£ng width c·ªßa s·ªë th·ª© t·ª±
        ctx.font = `normal 400 ${fit.fontPx}px system-ui, -apple-system, sans-serif`;
        listMarkerWidth = ctx.measureText(`${row.listNumber}.`).width;
      }
      const testWidth = tokensWidth + (hasList ? listIndent + listGap + listMarkerWidth : 0);

      let startX = innerLeft;
      if (align === 'center') startX = innerLeft + (innerWidth - testWidth) / 2;
      if (align === 'right')  startX = innerRight - testWidth;

      // V·∫Ω list marker (bullet ho·∫∑c s·ªë th·ª© t·ª±)
      let cursorX = startX;
      if (finalIsBullet) {
        // V·∫Ω bullet
        const r = Math.max(2, Math.round(fit.fontPx * 0.15));
        ctx.beginPath();
        ctx.arc(cursorX + r, ty + fit.fontPx * 0.5, r, 0, Math.PI * 2);
        ctx.fill();
        cursorX += listIndent + listGap;
      } else if (isOrdered && row.listNumber) {
        // V·∫Ω s·ªë th·ª© t·ª±
        ctx.font = `normal 400 ${fit.fontPx}px system-ui, -apple-system, sans-serif`;
        ctx.fillStyle = currentLayout.textColor || "#333";
        ctx.fillText(`${row.listNumber}.`, cursorX, ty);
        cursorX += listMarkerWidth + listGap;
      }

      // V·∫Ω tokens (ƒë·∫≠m/ nghi√™ng/ c·ª° ch·ªØ) theo th·ª© t·ª±
      drawTokensLine(ctx, row.tokens, cursorX, ty, fit.fontPx, currentLayout.textColor || "#333");

      // T√≠nh line height d·ª±a tr√™n c·ª° ch·ªØ l·ªõn nh·∫•t trong d√≤ng
      let maxFontPx = fit.fontPx;
      row.tokens.forEach(tk => {
        const actualFontPx = getFontSizeFromToken(tk, fit.fontPx);
        if (actualFontPx > maxFontPx) maxFontPx = actualFontPx;
      });
      const actualLineHeight = maxFontPx * lineH;
      
      ty += actualLineHeight;
      // N·∫øu v∆∞·ª£t qu√° khung text, d·ª´ng (tr√°nh v·∫Ω tr√†n)
      if (ty > textPx.y + textPx.h - padding) break;
    }
  }

  // ================= LOAD FRAMES FROM API =================
  const FRAME_API_BASE = "/api/frame-layout";
  const TEMPLATE_API_BASE = "/api/templates";

  async function loadFrameList() {
    const params = new URLSearchParams(window.location.search);
    const tplKey = params.get("tpl");             // template ƒë∆∞·ª£c ch·ªçn (n·∫øu c√≥)
    const frameKeyFromUrl = params.get("frame");  // optional: deep-link frame

    try {
      if (tplKey) {
        setStatus(`ƒêang t·∫£i frame c·ªßa template "${tplKey}"...`);
        const res = await fetch(`${TEMPLATE_API_BASE}/${encodeURIComponent(tplKey)}`);
        if (!res.ok) throw new Error("HTTP " + res.status);
        const data = await res.json();

        if (!data.frames || !data.frames.length) {
          setStatus("Template n√†y ch∆∞a c√≥ frame n√†o. H√£y c·∫•u h√¨nh frame_layouts v·ªõi template_id t∆∞∆°ng ·ª©ng.", true);
          frameSelect.innerHTML = "";
          return;
        }

        frames = data.frames; // [{layout_key, frame_url}, ...]
        frameSelect.innerHTML = "";
        frames.forEach(f => {
          const opt = document.createElement("option");
          opt.value = f.layout_key;
          opt.textContent = f.layout_key;
          frameSelect.appendChild(opt);
        });

        const initialKey = (frameKeyFromUrl && frames.some(f => f.layout_key === frameKeyFromUrl))
          ? frameKeyFromUrl
          : frames[0].layout_key;

        currentKey = initialKey;
        frameSelect.value = currentKey;

        await loadLayout(currentKey);
        setStatus(`Template: ${data.name || tplKey} ‚Ä¢ ƒêang d√πng frame "${currentKey}"`);
        return;
      }

      // Fallback: l·∫•y t·∫•t c·∫£ frame
      setStatus("ƒêang t·∫£i danh s√°ch frame...");

      const res = await fetch(FRAME_API_BASE);
      if (!res.ok) throw new Error("HTTP " + res.status);
      const list = await res.json();

      if (!list.length) {
        setStatus("Ch∆∞a c√≥ frame n√†o trong h·ªá th·ªëng.", true);
        frameSelect.innerHTML = "";
        return;
      }

      frames = list; // [{layout_key, ...}, ...]
      frameSelect.innerHTML = "";
      frames.forEach(f => {
        const opt = document.createElement("option");
        opt.value = f.layout_key;
        opt.textContent = f.layout_key;
        frameSelect.appendChild(opt);
      });

      const initialKey = (frameKeyFromUrl && frames.some(f => f.layout_key === frameKeyFromUrl))
        ? frameKeyFromUrl
        : frames[0].layout_key;

      currentKey = initialKey;
      frameSelect.value = currentKey;

      await loadLayout(currentKey);
      setStatus(`ƒêang d√πng frame "${currentKey}"`);
    } catch (err) {
      console.error(err);
      setStatus("Kh√¥ng load ƒë∆∞·ª£c danh s√°ch frame.", true);
    }
  }

  async function loadLayout(key) {
    layoutLoaded = false;
    frameLoaded = false;
    overlayImg = null;
    hasOverlay = false;

    if (overlayInput) overlayInput.value = "";
    updateOverlayButton();

    // --- Reset tr·∫°ng th√°i Overlay ---
    overlayZoom = 1.0;
    overlayOffsetX = 0;
    overlayOffsetY = 0;
    if (imageZoomEl) {
      imageZoomEl.value = 100;
      if (zoomImageLabel) zoomImageLabel.textContent = "100";
    }

    setStatus("ƒêang t·∫£i layout " + key + "...");
    try {
      const res = await fetch(`/api/frame-layout/${encodeURIComponent(key)}`);
      if (!res.ok) throw new Error("HTTP " + res.status);
      const data = await res.json();

      currentLayout = {
        frame_url: data.frame_url,
        textBox: data.textBox,
        imageBox: data.imageBox,
        textColor: data.textColor || "#333333",
        imageBorderColor: data.imageBorderColor || "#000000",
        textBoxColor: data.textBoxColor || "#22c55e",
        imageBoxColor: data.imageBoxColor || "#38bdf8",
      };

      await loadFrameImage(currentLayout.frame_url);
      layoutLoaded = true;
      setStatus(`ƒê√£ t·∫£i frame "${key}". Nh·∫≠p n·ªôi dung & ch·ªçn ·∫£nh.`);
      sizeChange();
    } catch (err) {
      console.error(err);
      setStatus("Kh√¥ng load ƒë∆∞·ª£c layout/frame.", true);
    }
  }

  function loadFrameImage(url) {
    return new Promise((resolve) => {
      frameImg = new Image();
      frameImg.onload = () => {
        frameLoaded = true;
        resolve();
      };
      frameImg.onerror = () => {
        setStatus("Kh√¥ng load ƒë∆∞·ª£c frame_url: " + url, true);
        resolve();
      };
      frameImg.src = url;
    });
  }

  // ================= EVENTS =================
  // ch·ªçn frame kh√°c
  safeAddListener(frameSelect, "change", async () => {
    const key = frameSelect.value;
    if (!key) return;
    currentKey = key;
    await loadLayout(currentKey);
    sizeChange();
  });

  // Event listeners ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω trong Quill text-change event

  // auto render khi thay ƒë·ªïi text / lineHeight / padding / exportSize
  ["input", "change"].forEach((ev) => {
    safeAddListener(textInput, ev, sizeChange);
    safeAddListener(lineHeightEl, ev, sizeChange);
    safeAddListener(paddingEl, ev, sizeChange);
    safeAddListener(exportSizeEl, ev, sizeChange);
  });

  // zoom preview
  if (previewZoomEl && zoomLabel) {
    const handleZoom = () => {
      zoomLabel.textContent = previewZoomEl.value;
      sizeChange();
    };
    previewZoomEl.addEventListener("input", handleZoom);
    previewZoomEl.addEventListener("change", handleZoom);
  }

  // zoom image overlay
  if (imageZoomEl && zoomImageLabel) {
    const handleImageZoom = () => {
      const zoomPercent = parseInt(imageZoomEl.value, 10);
      zoomImageLabel.textContent = zoomPercent;
      overlayZoom = zoomPercent / 100;
      // Clamp offset khi zoom thay ƒë·ªïi (v√¨ gi·ªõi h·∫°n thay ƒë·ªïi theo zoom)
      clampImageOffset();
      sizeChange();
    };
    imageZoomEl.addEventListener("input", handleImageZoom);
    imageZoomEl.addEventListener("change", handleImageZoom);
  }

  // n√∫t reset ·∫£nh
  safeAddListener(resetImageBtn, "click", () => {
    // Reset zoom v·ªÅ 100%
    if (imageZoomEl) {
      imageZoomEl.value = 100;
      overlayZoom = 1.0;
      if (zoomImageLabel) zoomImageLabel.textContent = "100";
    }
    // Reset offset v·ªÅ (0, 0)
    overlayOffsetX = 0;
    overlayOffsetY = 0;
    sizeChange();
  });

  // n√∫t ch·ªçn / g·ª° ·∫£nh
  safeAddListener(overlayToggleBtn, "click", () => {
    if (hasOverlay) {
      overlayImg = null;
      hasOverlay = false;
      if (overlayInput) overlayInput.value = "";
      updateOverlayButton();
      sizeChange();
    } else {
      if (overlayInput) overlayInput.click();
    }
  });

  // upload ·∫£nh overlay
  safeAddListener(overlayInput, "change", (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = () => {
      const img = new Image();
      img.onload = () => {
        overlayImg = img;
        hasOverlay = true;
        // Reset offset v·ªÅ 0 khi upload ·∫£nh m·ªõi (·∫£nh s·∫Ω ·ªü v·ªã tr√≠ m·∫∑c ƒë·ªãnh)
        overlayOffsetX = 0;
        overlayOffsetY = 0;
        updateOverlayButton();
        sizeChange();
      };
      img.src = reader.result;
    };
    reader.readAsDataURL(file);
  });

  // ================= DRAG TO PAN IMAGE =================
  let isDragging = false;
  let dragStartX = 0;
  let dragStartY = 0;
  let dragStartOffsetX = 0;
  let dragStartOffsetY = 0;

  // H√†m t√≠nh gi·ªõi h·∫°n offset ƒë·ªÉ ·∫£nh kh√¥ng k√©o ra ngo√†i khung
  function clampImageOffset(targetSize = BASE_SIZE) {
    if (!overlayImg || !currentLayout) return;

    const imagePx = boxPercentToPx(currentLayout.imageBox, targetSize);
    const ir2 = overlayImg.width / overlayImg.height;
    const br = imagePx.w / imagePx.h;
    
    // T√≠nh k√≠ch th∆∞·ªõc ban ƒë·∫ßu (cover mode)
    let initialW, initialH;
    if (ir2 > br) {
      initialH = imagePx.h;
      initialW = initialH * ir2;
    } else {
      initialW = imagePx.w;
      initialH = initialW / ir2;
    }

    // K√≠ch th∆∞·ªõc sau khi zoom
    const zoomedW = initialW * overlayZoom;
    const zoomedH = initialH * overlayZoom;

    // T√≠nh gi·ªõi h·∫°n offset
    // N·∫øu ·∫£nh l·ªõn h∆°n khung: c√≥ th·ªÉ k√©o trong ph·∫°m vi
    // N·∫øu ·∫£nh nh·ªè h∆°n khung: kh√¥ng th·ªÉ k√©o (offset = 0)
    
    let minOffsetX, maxOffsetX;
    if (zoomedW > imagePx.w) {
      // ·∫¢nh l·ªõn h∆°n khung: c√≥ th·ªÉ k√©o
      maxOffsetX = (zoomedW - imagePx.w) / 2;
      minOffsetX = -maxOffsetX;
    } else {
      // ·∫¢nh nh·ªè h∆°n khung: kh√¥ng th·ªÉ k√©o, ph·∫£i ·ªü gi·ªØa
      minOffsetX = 0;
      maxOffsetX = 0;
    }

    let minOffsetY, maxOffsetY;
    if (zoomedH > imagePx.h) {
      // ·∫¢nh l·ªõn h∆°n khung: c√≥ th·ªÉ k√©o
      maxOffsetY = (zoomedH - imagePx.h) / 2;
      minOffsetY = -maxOffsetY;
    } else {
      // ·∫¢nh nh·ªè h∆°n khung: kh√¥ng th·ªÉ k√©o, ph·∫£i ·ªü gi·ªØa
      minOffsetY = 0;
      maxOffsetY = 0;
    }

    // Clamp offset v·ªÅ trong gi·ªõi h·∫°n
    overlayOffsetX = Math.max(minOffsetX, Math.min(maxOffsetX, overlayOffsetX));
    overlayOffsetY = Math.max(minOffsetY, Math.min(maxOffsetY, overlayOffsetY));
  }

  // Helper function ƒë·ªÉ l·∫•y t·ªça ƒë·ªô t·ª´ mouse ho·∫∑c touch event
  function getEventCoords(e) {
    if (e.touches && e.touches.length > 0) {
      return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    }
    return { x: e.clientX, y: e.clientY };
  }

  const canvasWrap = document.querySelector('.canvas-wrap');
  if (canvasWrap) {
    // Mouse events (desktop)
    canvasWrap.addEventListener('mousedown', (e) => {
      if (!hasOverlay || !currentLayout) return;
      
      isDragging = true;
      const coords = getEventCoords(e);
      dragStartX = coords.x;
      dragStartY = coords.y;
      dragStartOffsetX = overlayOffsetX;
      dragStartOffsetY = overlayOffsetY;
      canvasWrap.style.cursor = 'grabbing';
      e.preventDefault();
    });

    // Helper function ƒë·ªÉ t√≠nh scale d·ª±a tr√™n canvas th·ª±c t·∫ø
    function calculateScale() {
      const previewZoom = parseInt(previewZoomEl?.value || "70", 10) / 100;
      // L·∫•y k√≠ch th∆∞·ªõc th·ª±c t·∫ø c·ªßa canvas tr√™n m√†n h√¨nh
      const canvasRect = canvas.getBoundingClientRect();
      const canvasDisplayWidth = canvasRect.width || (520 * previewZoom);
      return BASE_SIZE / canvasDisplayWidth;
    }

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;

      const scale = calculateScale();
      const coords = getEventCoords(e);
      const deltaX = (coords.x - dragStartX) * scale;
      const deltaY = (coords.y - dragStartY) * scale;

      // C·∫≠p nh·∫≠t offset t·∫°m th·ªùi
      overlayOffsetX = dragStartOffsetX + deltaX;
      overlayOffsetY = dragStartOffsetY + deltaY;

      // Gi·ªõi h·∫°n offset trong v√πng khung ·∫£nh
      clampImageOffset();

      sizeChange();
    });

    document.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        canvasWrap.style.cursor = 'grab';
      }
    });

    // Touch events (mobile)
    canvasWrap.addEventListener('touchstart', (e) => {
      if (!hasOverlay || !currentLayout) return;
      if (e.touches.length !== 1) return; // Ch·ªâ x·ª≠ l√Ω single touch
      
      isDragging = true;
      const coords = getEventCoords(e);
      dragStartX = coords.x;
      dragStartY = coords.y;
      dragStartOffsetX = overlayOffsetX;
      dragStartOffsetY = overlayOffsetY;
      e.preventDefault(); // NgƒÉn scroll khi drag
    }, { passive: false });

    canvasWrap.addEventListener('touchmove', (e) => {
      if (!isDragging || !hasOverlay) return;
      if (e.touches.length !== 1) return;

      const scale = calculateScale();
      const coords = getEventCoords(e);
      const deltaX = (coords.x - dragStartX) * scale;
      const deltaY = (coords.y - dragStartY) * scale;

      // C·∫≠p nh·∫≠t offset t·∫°m th·ªùi
      overlayOffsetX = dragStartOffsetX + deltaX;
      overlayOffsetY = dragStartOffsetY + deltaY;

      // Gi·ªõi h·∫°n offset trong v√πng khung ·∫£nh
      clampImageOffset();

      sizeChange();
      e.preventDefault(); // NgƒÉn scroll khi drag
    }, { passive: false });

    canvasWrap.addEventListener('touchend', (e) => {
      if (isDragging) {
        isDragging = false;
      }
    });

    canvasWrap.addEventListener('touchcancel', () => {
      if (isDragging) {
        isDragging = false;
      }
    });

    // Mouse hover effects (ch·ªâ desktop)
    canvasWrap.addEventListener('mouseenter', () => {
      if (hasOverlay && !isDragging) {
        canvasWrap.style.cursor = 'grab';
      }
    });

    canvasWrap.addEventListener('mouseleave', () => {
      canvasWrap.style.cursor = 'default';
    });
  }

  // download: desktop t·∫£i file, mobile/in-app m·ªü JPEG ƒë·ªÉ gi·ªØ-l∆∞u
  safeAddListener(downloadBtn, "click", () => {
    if (!frameLoaded || !layoutLoaded || !currentLayout) return;

    const size = parseInt(exportSizeEl?.value || "1080", 10);
    const fileName = `${currentKey || "frame"}_export.jpg`;

    // v·∫Ω b·∫£n s·∫°ch
    render(size, { forceHideBox: true });

    const ua = navigator.userAgent || "";
    const isIOS    = /iP(hone|od|ad)/i.test(ua);
    const isSafari = /^((?!chrome|android).)*safari/i.test(ua);
    const isInApp  = /(FBAN|FBAV|FB_IAB|FB4A|Instagram|Messenger)/i.test(ua);

    // xu·∫•t JPEG cho mobile/in-app
    const dataUrlJpeg = canvas.toDataURL("image/jpeg", 0.92);

    // In-app (Messenger / FB / IG): m·ªü trang ch·ªâ c√≥ ·∫£nh
    if (isInApp) {
      const html =
        '<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width,initial-scale=1">' +
        '<title>L∆∞u ·∫£nh</title></head>' +
        '<body style="margin:0;background:#000;display:flex;align-items:center;justify-content:center;">' +
        '<img src="' + dataUrlJpeg + '" style="max-width:100%;height:auto;display:block;" />' +
        '</body></html>';

      const win = window.open();
      if (win) {
        win.document.open();
        win.document.write(html);
        win.document.close();
      } else {
        document.open();
        document.write(html);
        document.close();
      }
      sizeChange();
      return;
    }

    // iOS Safari: m·ªü ·∫£nh ri√™ng ƒë·ªÉ long-press l∆∞u
    if (isIOS && isSafari) {
      const win = window.open();
      if (win) {
        win.document.open();
        win.document.write(
          '<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width,initial-scale=1">' +
          '<title>L∆∞u ·∫£nh</title></head>' +
          '<body style="margin:0;background:#000;display:flex;align-items:center;justify-content:center;">' +
          '<img src="' + dataUrlJpeg + '" style="max-width:100%;height:auto;display:block;" />' +
          '</body></html>'
        );
        win.document.close();
      } else {
        window.location.href = dataUrlJpeg;
      }
      sizeChange();
      return;
    }

    // Desktop + ƒëa s·ªë Android browser: t·∫£i file b√¨nh th∆∞·ªùng
    canvas.toBlob((blob) => {
      if (!blob) return;
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      sizeChange();
    });
  });

  // ================= INIT =================
  function sizeChange() {
    // Render preview theo k√≠ch th∆∞·ªõc g·ªëc BASE_SIZE
    render(BASE_SIZE);
  }

  (async function init() {
    updateOverlayButton();
    setStatus("ƒêang t·∫£i danh s√°ch frame...");
    await loadFrameList();

    if (document.fonts && document.fonts.ready) {
      document.fonts.ready.then(sizeChange);
    } else {
      sizeChange();
    }

    window.addEventListener("resize", sizeChange);
  })();
</script>




</body>
</html>
