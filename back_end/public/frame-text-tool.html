<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <title>Frame Text Tool</title>
  <link rel="icon" href="Logo.jpg" type="image/x-icon">  
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css"
  />
  <style>
    :root{
      /* ===== Brand palette (Red + Beige are primary) ===== */
      --brand-red:        #DC2626;   /* primary red */
      --brand-red-700:    #B91C1C;   /* hover/depth */
      --brand-red-900:    #7F1D1D;   /* strong accent */
      --brand-beige:      #F4E8D8;   /* primary beige (page bg) */
      --brand-beige-200:  #EFE0CC;   /* panels */
      --brand-beige-300:  #E8D6C0;   /* inputs */
      --brand-beige-50:   #FBF6EE;   /* soft highlights */
      --ink:              #1A1A1A;   /* text (secondary color) */
      --border:           rgba(185,28,28,0.25);  /* red-tinted border */
      --border-soft:      rgba(185,28,28,0.15);
      --shadow:           rgba(185,28,28,0.22);
    }

    /* ===== Page layout ===== */
    body{
      background-image: url('background.png');
      margin:0; padding:16px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background:
        radial-gradient(900px 600px at 85% -10%, rgba(220,38,38,0.10), transparent 60%),
        radial-gradient(900px 600px at 0% 110%, rgba(220,38,38,0.08), transparent 60%),
        var(--brand-beige);                /* BEIGE is the main background */
      color: var(--ink);
      min-height:100vh;
      display:flex; flex-direction:column; align-items:center; gap:12px;
      box-sizing:border-box;
    }

    /* Wrap your main two columns if you have them */
    .sidebar{
      width:320px;
      padding:18px;
      border-right:1px solid var(--border-soft);
      background:
        linear-gradient(180deg, var(--brand-beige-50), var(--brand-beige-200));
      display:flex; flex-direction:column; gap:12px;
      box-sizing:border-box;
      border-radius:14px;
      box-shadow: 0 10px 30px var(--shadow);
    }

    .main{
      flex:1;
      display:flex;
      align-items:center; justify-content:center;
      padding:18px; box-sizing:border-box;
    }

    .canvas-wrap{
      padding:16px;
      border-radius:24px;
      background:
        linear-gradient(180deg, var(--brand-beige-50), var(--brand-beige-200));
      border:1px solid var(--border);
      box-shadow: 0 24px 70px var(--shadow);
    }

    canvas{
      display:block;
      width:520px; height:520px;
      border-radius:18px;
      background: var(--brand-beige-50);  /* kh√¥ng c√≤n n·ªÅn ƒëen */
      border:1px solid var(--border-soft);
    }

    /* ===== Typography ===== */
    .tag {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-weight: 600;
      color: var(--brand-red-900);
    }

    .tag i {
      font-size: 1.1em;
      color: var(--brand-red);
    }
    h1{
      margin:0 0 6px 0;
      font-size:18px; font-weight:800;
      color: var(--brand-red);            /* ti√™u ƒë·ªÅ ƒë·ªè */
    }
    p, .status{ margin:0; font-size:12px; color:#6b5346; }

    label{
      font-size:12px; color:#7a5c4b;
      margin-bottom:4px; display:block;
    }

    /* ===== Inputs ===== */
    select, textarea, input[type="text"], input[type="number"]{
      width:100%; padding:8px 10px;
      border-radius:12px;
      border:1px solid var(--border);
      background: var(--brand-beige-300);
      color: var(--ink); font-size:12px;
      outline:none; box-sizing:border-box;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.35);
    }
    input[type="range"]{ width:100%; accent-color: var(--brand-red); }

    select:focus, textarea:focus, input[type="text"]:focus, input[type="number"]:focus, .rte-editor:focus{
      border-color: var(--brand-red-700);
      box-shadow: 0 0 0 3px rgba(220,38,38,0.20);
    }

    .row{ display:flex; gap:8px; align-items:center; justify-content:space-between; }
    .row label{ margin:0; }

    /* ===== Buttons ===== */
    .btn{
      padding:8px 14px; border-radius:999px;
      border:1px solid var(--brand-red-700);
      background: linear-gradient(180deg, var(--brand-red), var(--brand-red-700));
      color: #FFF7F0; font-size:12px; font-weight:800;
      cursor:pointer; display:inline-flex; align-items:center; gap:6px;
      text-transform: uppercase; letter-spacing: .02em;
      box-shadow: 0 12px 28px rgba(220,38,38,0.35);
      transition: transform .15s ease, box-shadow .15s ease, filter .15s ease;
    }
    .btn:hover{
      transform: translateY(-1px);
      box-shadow: 0 16px 36px rgba(220,38,38,0.45);
      filter: brightness(1.05);
    }

    /* ===== Upload (beige primary secondary to red) ===== */
    .upload-wrapper{
      display: flex;
      flex-direction: column;
      gap: 6px;
      align-items: center;        /* <-- cƒÉn gi·ªØa to√†n b·ªô trong wrapper */
      text-align: center;
    }
    .upload-btn{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 14px; border-radius:999px; cursor:pointer;
      border:1px solid var(--border);
      background: var(--brand-beige-50);
      color: var(--ink);
      font-size:12px; font-weight:700;
      box-shadow: 0 6px 14px rgba(220,38,38,0.18);
      transition: transform .15s ease, box-shadow .15s ease, background .15s ease;
    }
    .upload-btn:hover{
      transform: translateY(-1px);
      background: var(--brand-beige);
      box-shadow: 0 10px 22px rgba(220,38,38,0.28);
    }
    .upload-icon{ font-size:14px; }
    .upload-hint{ font-size:11px; color:#7a5c4b; }

    /* ===== Rich Text Editor ===== */
    .rte-toolbar{
      display:flex; align-items:center; gap:6px;
      padding:6px; border:1px solid var(--border);
      border-radius:10px 10px 0 0;
      background: var(--brand-beige-200);
    }
    .rte-btn{
      border:1px solid var(--border);
      background: var(--brand-beige-50);
      color: var(--ink);
      padding:4px 8px; font-size:12px; border-radius:8px; cursor:pointer;
      transition: background .15s ease, color .15s ease, border-color .15s ease;
    }
    .rte-btn:hover{
      background: #FBE9E7;
      border-color: var(--brand-red-700);
      color: var(--brand-red-900);
    }
    .rte-sep{ width:1px; height:18px; background: var(--border); margin:0 2px; }

    .rte-editor{
      min-height:120px; padding:10px 12px;
      border:1px solid var(--border); border-top:none;
      border-radius:0 0 10px 10px;
      background: var(--brand-beige-50);
      color: var(--ink);
      font-size:13px; line-height:1.6; outline:none; white-space:pre-wrap;
    }
    .rte-editor:empty:before{ content:attr(placeholder); color:#967a67; }
    .rte-editor[ data-align="center" ]{ text-align:center; }
    .rte-editor[ data-align="right" ]{ text-align:right; }

    /* ===== Chips / badges (n·∫øu c√≥) ===== */
    .badge{
      display:inline-flex; align-items:center; gap:6px;
      padding:4px 8px; border-radius:999px;
      background:#FBE9E7; color: var(--brand-red-900);
      border:1px solid var(--border);
      font-size:11px; font-weight:700;
    }

    /* ===== Small helpers ===== */
    .card{
      background: linear-gradient(180deg, var(--brand-beige-50), var(--brand-beige));
      border:1px solid var(--border-soft);
      border-radius:16px; padding:12px;
      box-shadow: 0 10px 26px var(--shadow);
    }
    /* === Layout fix: sidebar tr√°i, canvas ph·∫£i === */
    body{
      display:flex;
      flex-direction: row;           /* <-- ƒë·ªïi t·ª´ column sang row */
      align-items: flex-start;       /* sidebar kh√¥ng b·ªã cƒÉn gi·ªØa theo tr·ª•c d·ªçc */
      gap: 16px;                     /* kho·∫£ng c√°ch gi·ªØa sidebar & main */
      background: url('background2.png');
      flex-wrap: wrap;
    }

    /* Sidebar c·ªë ƒë·ªãnh b·ªÅ r·ªông v√† d√≠nh b√™n tr√°i */
    .sidebar{
      width: 320px;                  /* b·ªÅ r·ªông c·ªôt tr√°i */
      flex: 0 0 320px;               /* kh√¥ng co gi√£n */
      height: calc(100vh - 32px);    /* tr·ª´ padding body 16px tr√™n/d∆∞·ªõi n·∫øu c√≥ */
      position: sticky;              /* d√≠nh khi cu·ªôn */
      top: 16px;
      overflow: auto;                /* cu·ªôn n·ªôi dung n·∫øu d√†i */
      box-sizing: border-box;
      -ms-overflow-style: none;  /* IE/Edge c≈© */
      scrollbar-width: none;     /* Firefox */
    }
    .sidebar::-webkit-scrollbar{ /* Chrome/Safari/Opera */
      width: 0;
      height: 0;
    }

    /* Khu v·ª±c ch√≠nh chi·∫øm ph·∫ßn c√≤n l·∫°i */
    .main{
      flex: 1 1 auto;                /* gi√£n h·∫øt ph·∫ßn c√≤n l·∫°i */
      min-width: 0;                  /* tr√°nh overflow ngang khi c√≥ canvas to */
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* ƒê·∫£m b·∫£o canvas √¥m v·ª´a, kh√¥ng tr√†n */
    .canvas-wrap{
      max-width: 100%;
    }
    canvas{
      max-width: 100%;
      height: auto;
    }

    /* === Responsive: d∆∞·ªõi 900px th√¨ x·∫øp d·ªçc nh∆∞ mobile (sidebar ph√≠a tr√™n l√† OK) === */
    @media (max-width: 900px){
      body{
        flex-direction: column;      /* mobile gi·ªØ d·ªçc */
        align-items: stretch;
      }
      .sidebar{
        position: static;
        width: 100%;
        height: auto;
      }
      .main{
        width: 100%;
        justify-content: center;
      }
    }
    /* ===== Header (ƒë·ªè & be l√† ch·ªß ƒë·∫°o) ===== */
    .app-header{
      flex: 0 0 100%;
      order: -1;
      align-self: stretch;
      width: 100%;
      top: 0; z-index: 1000;
      display: grid;
      grid-template-columns: 1fr auto 1fr; /* tr√°i | gi·ªØa | ph·∫£i */
      align-items: center;
      gap: 12px;

      padding: 10px 14px;
      margin-bottom: 12px;
      border: 1px solid var(--border);
      border-radius: 14px;

      background: linear-gradient(180deg, var(--brand-beige-50), var(--brand-beige-200));
      box-shadow: 0 10px 26px var(--shadow);
    }

    /* C·ªôt tr√°i/gi·ªØa/ph·∫£i */
    .header-left{ display:flex; align-items:center; gap:10px; }
    .header-center{ display:flex; justify-content:center; }
    .header-right{
      display:flex; justify-content:flex-end; align-items:center; gap:10px;
    }

    /* Back link */
    .back-link{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 12px;
      border-radius:999px;
      border:1px solid var(--brand-red-700);
      background: linear-gradient(180deg, var(--brand-red), var(--brand-red-700));
      color:#FFF7F0; text-decoration:none; font-weight:800; font-size:12px;
      box-shadow: 0 8px 20px rgba(220,38,38,.3);
      transition: transform .15s ease, box-shadow .15s ease, filter .15s ease;
    }
    .back-link:hover{
      transform: translateY(-1px); filter: brightness(1.05);
      box-shadow: 0 12px 28px rgba(220,38,38,.4);
    }
    .back-ico{ font-size:14px; line-height:1; }

    /* Ti√™u ƒë·ªÅ trung t√¢m */
    .brand-title{
      margin:0; font-size:14px; font-weight:900; letter-spacing:.02em;
      color: var(--brand-red-900);
    }

    /* N√∫t MXH */
    .social-btn{
      display:inline-flex; align-items:center; justify-content:center;
      width:34px; height:34px; border-radius:10px;
      color: var(--brand-red-900); background: var(--brand-beige-50);
      border:1px solid var(--border);
      transition: transform .15s ease, background .15s ease, color .15s ease;
    }
    .social-btn:hover{
      transform: translateY(-1px);
      background:#FBE9E7; color: var(--brand-red-700);
    }

    /* Responsive: d∆∞·ªõi 900px x·∫øp l·∫°i */
    /* === Mobile split view: 1 b√™n sidebar | 1 b√™n canvas === */
    @media (max-width: 900px){
      :root{
        /* ∆∞·ªõc l∆∞·ª£ng chi·ªÅu cao header ƒë·ªÉ t√≠nh chi·ªÅu cao c√≤n l·∫°i (tu·ª≥ padding c·ªßa b·∫°n) */
        --header-h: 72px;
      }

      /* D√πng grid ƒë·ªÉ ƒë·∫∑t header ·ªü h√†ng 1 (tr√†n 2 c·ªôt), d∆∞·ªõi l√† 2 c·ªôt ngang */
      body{
        display: grid;
        grid-template-columns: 1fr 1fr;     /* 2 c·ªôt b·∫±ng nhau: sidebar | canvas */
        grid-auto-rows: minmax(0, 1fr);
        align-items: stretch;
        gap: 8px;
        padding: 8px;                       /* gi·∫£m padding tr√™n mobile */
        height: 100dvh;                      /* full chi·ªÅu cao viewport ƒë·ªông tr√™n mobile */
        overflow: hidden;                    /* ch·∫∑n body k√©o d√†i v√¥ h·∫°n */
        background: url('background2.png');
      }

      /* Header chi·∫øm full h√†ng tr√™n c√πng, d√≠nh tr√™n */
      .app-header{
        grid-column: 1 / -1;
        position: sticky;
        top: 0;
        z-index: 1000;
        margin: 0;                           /* lo·∫°i b·ªè margin-bottom ƒë·ªÉ kh·ªèi ‚Äúƒë·ªôi‚Äù chi·ªÅu cao */
        border-radius: 12px;
      }

      /* Hai c·ªôt: m·ªói c·ªôt t·ª± cu·ªôn n·∫øu n·ªôi dung d√†i */
      .sidebar,
      .main{
        min-width: 0;                        /* tr√°nh tr√†n ngang */
        height: calc(100dvh - var(--header-h) - 16px); /* 16px = gap + vi·ªÅn/padding nh·∫π */
        overflow: auto;                      /* cu·ªôn trong t·ª´ng c·ªôt */
        box-sizing: border-box;
      }

      /* Sidebar: b·ªõt c·∫£m gi√°c ‚Äútr√†n d·ªçc‚Äù */
      .sidebar{
        width: auto;                         /* b·ªè c·ªë ƒë·ªãnh 320px ·ªü mobile */
        flex: 0 1 auto;                      /* kh√¥ng c·ªë ƒë·ªãnh co gi√£n nh∆∞ desktop */
        padding: 12px 10px;
        position: static;                    /* t·∫Øt sticky ƒë·ªÉ kh√¥ng k√©o d√†i to√†n chi·ªÅu d·ªçc */
        border-radius: 12px;
      }
      .sidebar::-webkit-scrollbar{ width: 0; height: 0; }  /* ·∫©n scrollbar cho g·ªçn */

      .main{
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 10px;
      }

      .canvas-wrap{
        width: 100%;
        max-width: 100%;
        padding: 10px;
        border-radius: 16px;
      }

      canvas{
        width: 100%;       /* co gi√£n theo c·ªôt ph·∫£i */
        height: auto;
      }

      /* T·ªëi ∆∞u touch target tr√™n mobile */
      .btn, .upload-btn, select, input, textarea{
        font-size: 14px;
        padding: 10px 14px;
      }
      .rte-btn{ padding: 6px 10px; }
      label{ font-size: 13px; }
    }


    /* Icon-only back button */
    .back-icon{
      display:inline-flex; align-items:center; justify-content:center;
      width: 36px; height: 36px; border-radius: 999px;
      background: var(--brand-beige-50);
      color: var(--brand-red-900);
      border: 1px solid var(--border);
      box-shadow: 0 6px 16px rgba(220,38,38,.18);
      text-decoration: none;
      transition: transform .15s ease, background .15s ease, color .15s ease, box-shadow .15s ease;
    }
    .back-icon:hover{
      transform: translateY(-1px);
      background: #FBE9E7;            /* beige s√°ng h∆°n */
      color: var(--brand-red-700);
      box-shadow: 0 10px 24px rgba(220,38,38,.28);
    }

    /* N·∫øu mu·ªën phi√™n b·∫£n n·ªÅn ƒë·ªè (ƒë·∫≠m h∆°n), b·ªè comment ƒëo·∫°n d∆∞·ªõi v√† thay class .back-icon-red trong HTML */
    
    .back-icon.back-icon-red{
      background: linear-gradient(180deg, var(--brand-red), var(--brand-red-700));
      color: #FFF7F0;
      border-color: var(--brand-red-700);
    }
    .back-icon.back-icon-red:hover{
      filter: brightness(1.05);
    }
    /* --- D·ªãch c√°c icon MXH sang tr√°i --- */
    .header-right {
      justify-content: flex-end;
      gap: 8px;
      margin-right: 60px; /* ho·∫∑c gi·∫£m gi√° tr·ªã n√†y n·∫øu mu·ªën d·ªãch √≠t h∆°n */
      transform: translateX(-8px); /* d·ªãch to√†n b·ªô nh√≥m icon sang tr√°i */
    }

    /* --- N√∫t quay v·ªÅ: hover chuy·ªÉn ƒë·ªè, m≈©i t√™n tr·∫Øng --- */
    .back-icon {
      background: var(--brand-beige-50);
      color: var(--brand-red-900);
      border: 1px solid var(--border);
      box-shadow: 0 6px 16px rgba(220,38,38,.18);
      transition: transform .15s ease, background .15s ease, color .15s ease, box-shadow .15s ease;
    }

    .back-icon:hover {
      background: var(--brand-red); /* chuy·ªÉn n·ªÅn sang ƒë·ªè */
      color: white; /* m≈©i t√™n chuy·ªÉn tr·∫Øng */
      box-shadow: 0 10px 24px rgba(220,38,38,.35);
      transform: translateY(-1px);
    }

   


  
  </style>


</head>
<body>
  <header class="app-header">
    <div class="header-left">
      <a class="back-icon" href="/template-select.html" title="Quay l·∫°i trang ch·ªçn template" aria-label="Quay l·∫°i trang ch·ªçn template">
        <!-- Arrow Left -->
        <svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true">
          <path fill="currentColor" d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2Z"/>
        </svg>
      </a>
    </div>

    <div class="header-center">
      <h1 class="brand-title"></h1>
    </div>

    <nav class="header-right" aria-label="Social links">
      <a class="social-btn" href="https://www.facebook.com/banstudioHN" target="_blank" rel="noopener">
        <!-- Facebook -->
        <svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true">
          <path fill="currentColor" d="M22 12.07C22 6.48 17.52 2 11.93 2S2 6.48 2 12.07c0 5.02 3.66 9.18 8.44 9.93v-7.03H7.9v-2.9h2.54V9.41c0-2.5 1.49-3.88 3.77-3.88 1.09 0 2.23.2 2.23.2v2.45h-1.26c-1.24 0-1.62.77-1.62 1.56v1.87h2.76l-.44 2.9h-2.32V22c4.78-.75 8.44-4.91 8.44-9.93Z"/>
        </svg>
      </a>
      <a class="social-btn" href="https://www.instagram.com/banvaii/" target="_blank" rel="noopener">
        <!-- Instagram -->
        <svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true">
          <path fill="currentColor" d="M7 2h10a5 5 0 0 1 5 5v10a5 5 0 0 1-5 5H7a5 5 0 0 1-5-5V7a5 5 0 0 1 5-5Zm0 2a3 3 0 0 0-3 3v10a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3V7a3 3 0 0 0-3-3H7Zm5 3.5A5.5 5.5 0 1 1 6.5 13 5.5 5.5 0 0 1 12 7.5Zm0 2A3.5 3.5 0 1 0 15.5 13 3.5 3.5 0 0 0 12 9.5ZM18 6.2a1 1 0 1 0 1 1 1 1 0 0 0-1-1Z"/>
        </svg>
      </a>
      <a class="social-btn" href="https://www.tiktok.com/@aobanvai" target="_blank" rel="noopener">
        <!-- TikTok -->
        <svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true">
          <path fill="currentColor" d="M14.5 3.1v8.2a3.9 3.9 0 1 1-3.9-3.9c.2 0 .5 0 .7.1V5.06a7.02 7.02 0 0 0-.7-.04A6.94 6.94 0 1 0 17.54 12V9.58a7.2 7.2 0 0 0 4.46 1.52V8.1a4.7 4.7 0 0 1-4.46-5Z"/>
        </svg>
      </a>
    </nav>
  </header>

  <div class="sidebar">
    <div>
      <h1>Frame Text Tool</h1>
      <p>Ch·ªçn frame, nh·∫≠p n·ªôi dung, ch·ªçn ·∫£nh. V·ªã tr√≠ khung ƒë√£ ƒë∆∞·ª£c c·ªë ƒë·ªãnh.</p>
    </div>

    <div>
      <label>Ch·ªçn frame</label>
      <select id="frameSelect"></select>
      <div class="status" id="statusText">ƒêang t·∫£i danh s√°ch frame...</div>
    </div>

    <!-- Thay th·∫ø nguy√™n kh·ªëi: label + textarea -->
    <div>
      <label>N·ªôi dung text</label>

      <!-- Toolbar -->
      <div class="rte-toolbar">
        <button type="button" data-cmd="bold"      class="rte-btn"><b>B</b></button>
        <button type="button" data-cmd="italic"    class="rte-btn"><i>I</i></button>
        <span class="rte-sep"></span>
        <button type="button" data-align="left"    class="rte-btn">‚ü∏</button>
        <button type="button" data-align="center"  class="rte-btn">‚áî</button>
        <button type="button" data-align="right"   class="rte-btn">‚üπ</button>
        <span class="rte-sep"></span>
        <button type="button" id="btnBullets"      class="rte-btn">‚Ä¢ List</button>
      </div>

      <!-- Editor -->
      <div id="richText"
          contenteditable="true"
          data-align="left"
          class="rte-editor"
          placeholder="Nh·∫≠p m√¥ t·∫£ / n·ªôi dung..."></div>
      <!-- (T√πy ch·ªçn) ·∫®n textarea c≈© ƒë·ªÉ gi·ªØ compatibility -->
      <textarea id="textInput" style="display:none;"></textarea>
    </div>


    <div class="row">
      <div style="flex:1">
        <label>Gi√£n d√≤ng</label>
        <input id="lineHeight" type="number" step="0.1" min="0.8" max="2.0" value="1.2" />
      </div>
      <div style="flex:1">
        <label>Padding (px)</label>
        <input id="padding" type="number" min="0" max="80" value="10" />
      </div>
    </div>

    <div class="row">
      <div style="flex:1">
        <label>K√≠ch th∆∞·ªõc xu·∫•t (px)</label>
        <input id="exportSize" type="number" min="600" max="2000" step="60" value="1080" />
      </div>
      <div style="flex:1">
        <label>Zoom xem tr∆∞·ªõc (<span id="zoomLabel">70</span>%)</label>
        <input id="previewZoom" type="range" min="30" max="120" step="5" value="70" />
      </div>
    </div>
    
    <div class="upload-wrapper">
      <label>·∫¢nh c·ªßa b·∫°n</label>
      <button type="button" id="overlayToggleBtn" class="upload-btn">
        <span id="overlayBtnText">
          <i class="bi bi-camera-fill"></i> Ch·ªçn ·∫£nh
        </span>
      </button>

      <input id="overlayInput" type="file" accept="image/*" style="display:none" />
      <div class="upload-hint">PNG/JPG ‚Ä¢ S·∫Ω t·ª± cƒÉn v√†o khung ·∫£nh ƒë√£ thi·∫øt k·∫ø.</div>
    </div>

    <!-- Crop/Pan Controls -->
    <div id="cropControls" style="display:none; border-top:1px solid var(--border-soft); padding-top:12px; gap:8px; display:flex; flex-direction:column;">
      <div class="row">
        <div style="flex:1">
          <label>Zoom ·∫£nh (<span id="zoomImageLabel">100</span>%)</label>
          <input id="imageZoom" type="range" min="50" max="200" step="10" value="100" />
        </div>
      </div>
      <button type="button" id="resetImageBtn" class="btn" style="margin:0; width:100%; font-size:11px; padding:6px 10px;">
        <i class="bi bi-arrow-counterclockwise"></i> ƒê·∫∑t l·∫°i
      </button>
      <div style="font-size:11px; color:#7a5c4b; text-align:center;">
        üí° K√©o ·∫£nh tr√™n khung ƒë·ªÉ ƒëi·ªÅu ch·ªânh v·ªã tr√≠
      </div>
    </div>



    <button
      class="btn"
      id="downloadBtn"
      style="
        font-family:-apple-system,'Segoe UI',Tahoma,'Helvetica Neue',Arial,'DejaVu Sans',Ubuntu,Cantarell,'Noto Sans',sans-serif;
        font-weight:700; letter-spacing:.02em;
        display:block;            /* ƒë·ªÉ margin auto c√≥ t√°c d·ª•ng */
        margin:8px auto 0;        /* cƒÉn gi·ªØa ngang */
        text-align:center;        /* cƒÉn gi·ªØa n·ªôi dung */
        align-self:center;        /* n·∫øu parent l√† flex th√¨ v·∫´n gi·ªØa */
      "
    >
      <i class="bi bi-download"></i> Xu·∫•t ·∫£nh PNG
    </button>

  </div>

  <div class="main">
    <div class="canvas-wrap">
      <canvas id="canvas" width="1080" height="1080"></canvas>
    </div>
  </div>

<script>
  // ================= CONFIG =================
  const API_BASE = "/api/frame-layout"; // relative: ch·∫°y ƒë∆∞·ª£c c·∫£ localhost & ngrok
  const BASE_SIZE = 1080;
  const DEFAULT_OVERLAY_RADIUS = 20;
  const DEFAULT_OVERLAY_ALPHA = 1;
  const FIT_MODE = "cover";

  // ================= DOM =================
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");

  const frameSelect = document.getElementById("frameSelect");
  const statusText = document.getElementById("statusText");

  const textInput = document.getElementById("textInput");
  const lineHeightEl = document.getElementById("lineHeight");
  const paddingEl = document.getElementById("padding");
  const exportSizeEl = document.getElementById("exportSize");
  const previewZoomEl = document.getElementById("previewZoom");
  const zoomLabel = document.getElementById("zoomLabel");

  const overlayInput = document.getElementById("overlayInput");
  const overlayToggleBtn = document.getElementById("overlayToggleBtn");
  const overlayBtnText = document.getElementById("overlayBtnText");
  const overlayBtnIcon = document.getElementById("overlayBtnIcon");

  const downloadBtn = document.getElementById("downloadBtn");
  const richText = document.getElementById("richText");

  const imageZoomEl = document.getElementById("imageZoom");
  const zoomImageLabel = document.getElementById("zoomImageLabel");
  const cropControls = document.getElementById("cropControls");
  const resetImageBtn = document.getElementById("resetImageBtn");

  // ================= STATE =================
  let frames = [];
  let currentKey = null;
  let currentLayout = null; // { frame_url, textBox, imageBox, colors... }

  let frameImg = new Image();
  let frameLoaded = false;
  let layoutLoaded = false;

  let overlayImg = null;
  let hasOverlay = false;
  // --- Th√™m bi·∫øn tr·∫°ng th√°i cho ·∫£nh Overlay ---
  let overlayZoom = 1.0;          // T·ªâ l·ªá zoom c·ªßa ·∫£nh g·ªëc (1.0 = fit)
  let overlayOffsetX = 0;         // D·ªãch chuy·ªÉn X (px)
  let overlayOffsetY = 0;         // D·ªãch chuy·ªÉn Y (px)
  // ------------------------------------------

  // ================= HELPERS =================
  function setStatus(msg, error = false) {
    if (!statusText) return;
    statusText.textContent = msg;
    statusText.style.color = error ? "#f97316" : "#6b7280";
  }

  function safeAddListener(el, ev, fn) {
    if (el) el.addEventListener(ev, fn);
  }

  function boxPercentToPx(box, size) {
    return {
      x: (box.x / 100) * size,
      y: (box.y / 100) * size,
      w: (box.w / 100) * size,
      h: (box.h / 100) * size,
    };
  }

  // ===== Toolbar wiring (bold/italic/align/bullets) =====
  document.querySelectorAll('.rte-toolbar .rte-btn[data-cmd]')?.forEach(btn => {
    btn.addEventListener('click', () => {
      const cmd = btn.getAttribute('data-cmd');
      if (!richText) return;
      richText.focus();
      document.execCommand(cmd, false, null);
      sizeChange();
    });
  });

  document.querySelectorAll('.rte-toolbar .rte-btn[data-align]')?.forEach(btn => {
    btn.addEventListener('click', () => {
      if (!richText) return;
      const align = btn.getAttribute('data-align'); // left/center/right
      richText.setAttribute('data-align', align);
      sizeChange();
    });
  });

  const btnBullets = document.getElementById('btnBullets');
  if (btnBullets) {
    btnBullets.addEventListener('click', () => {
      if (!richText) return;
      // Chu·∫©n h√≥a: n·∫øu kh√¥ng c√≥ selection, √°p d·ª•ng cho to√†n b·ªô n·ªôi dung
      const lines = getEditorPlainText().split('\n').map(t => {
        const s = t.trimStart();
        if (s.startsWith('‚Ä¢ ')) return t.replace(/^\s*‚Ä¢\s/, ''); // b·ªè bullet
        return (t.length ? '‚Ä¢ ' + t : t); // th√™m bullet
      });
      // Thay n·ªôi dung (gi·ªØ xu·ªëng d√≤ng)
      richText.innerText = lines.join('\n');
      sizeChange();
    });
  }

  function getEditorAlign() {
    const a = richText?.getAttribute('data-align');
    return a === 'center' || a === 'right' ? a : 'left';
  }

  function getEditorPlainText() {
    return (richText?.innerText || "").replace(/\r/g, "");
  }

  // Tr·∫£ v·ªÅ [{ tokens:[{type:'text'|'bold'|'italic', text:'...'}], bullet:boolean }]
  function serializeEditorToLines() {
    if (!richText) return [];

    // N·∫øu ng∆∞·ªùi d√πng ch·ªâ g√µ plain text (kh√¥ng HTML), x·ª≠ l√Ω nhanh: t√°ch theo \n, v√† nh·∫≠n di·ªán '‚Ä¢ ' ·ªü ƒë·∫ßu d√≤ng
    const hasInlineHtml = richText.querySelector('b,strong,i,em,ul,ol,li,br,p,div') !== null;
    if (!hasInlineHtml) {
      const plain = getEditorPlainText().split('\n');
      if (!plain.length) return [{ tokens:[{type:'text', text:''}], bullet:false }];
      return plain.map(line => {
        const bullet = /^\s*‚Ä¢\s+/.test(line);
        const text = bullet ? line.replace(/^\s*‚Ä¢\s+/, '') : line;
        return { tokens:[{type:'text', text}], bullet };
      });
    }

    // C√≥ HTML: t·∫°o b·∫£n sao ƒë·ªÉ thao t√°c an to√†n
    const clone = richText.cloneNode(true);
    const lines = [];

    // N·∫øu c√≥ danh s√°ch ul/ol
    clone.querySelectorAll('ul,ol').forEach(list => {
      list.querySelectorAll('li').forEach(li => {
        lines.push({
          tokens: inlineTokensFromNode(li),
          bullet: true
        });
      });
      list.remove();
    });

    // C√°c block c√≤n l·∫°i: div/p
    clone.childNodes.forEach(node => {
      if (node.nodeType === Node.ELEMENT_NODE) {
        const tag = node.tagName?.toLowerCase();
        if (tag === 'div' || tag === 'p') {
          splitByBr(node).forEach(seg => {
            const tokens = inlineTokensFromNode(seg);
            // N·∫øu ng∆∞·ªùi d√πng g√µ k√Ω t·ª± ‚Ä¢ ·ªü ƒë·∫ßu, nh·∫≠n di·ªán lu√¥n
            const isBulletChar = tokens.length && typeof tokens[0].text === 'string' && /^\s*‚Ä¢\s+/.test(tokens[0].text);
            if (isBulletChar) {
              tokens[0].text = tokens[0].text.replace(/^\s*‚Ä¢\s+/, '');
            }
            lines.push({ tokens, bullet: isBulletChar ? true : false });
          });
        } else if (tag === 'br') {
          lines.push({ tokens: [{ type: 'text', text: '' }], bullet: false });
        } else {
          // inline element ·ªü root
          const tokens = inlineTokensFromNode(node);
          if (tokens.length) {
            // Nh·∫≠n di·ªán '‚Ä¢ ' n·∫øu c√≥
            const isBulletChar = tokens.length && typeof tokens[0].text === 'string' && /^\s*‚Ä¢\s+/.test(tokens[0].text);
            if (isBulletChar) tokens[0].text = tokens[0].text.replace(/^\s*‚Ä¢\s+/, '');
            lines.push({ tokens, bullet: isBulletChar });
          }
        }
      } else if (node.nodeType === Node.TEXT_NODE) {
        const parts = (node.nodeValue || '').replace(/\r/g, '').split('\n');
        parts.forEach(p => {
          const bullet = /^\s*‚Ä¢\s+/.test(p);
          const text = bullet ? p.replace(/^\s*‚Ä¢\s+/, '') : p;
          lines.push({ tokens: [{ type: 'text', text }], bullet });
        });
      }
    });

    if (!lines.length) lines.push({ tokens: [{ type: 'text', text: '' }], bullet: false });
    return lines;
  }

  // Chia 1 element theo <br> th√†nh nhi·ªÅu "ƒëo·∫°n" element nh·ªè ƒë·ªÉ d·ªÖ token ho√°
  function splitByBr(el) {
    const out = [];
    let current = document.createElement('span');
    el.childNodes.forEach(n => {
      if (n.nodeType === Node.ELEMENT_NODE && n.tagName?.toLowerCase() === 'br') {
        out.push(current);
        current = document.createElement('span');
      } else {
        current.appendChild(n.cloneNode(true));
      }
    });
    out.push(current);
    return out;
  }

  // L·∫•y tokens inline t·ª´ 1 node: hi·ªÉu <b>/<strong> l√† bold, <i>/<em> l√† italic
  function inlineTokensFromNode(node) {
    const tokens = [];
    const walk = (n, styleCtx) => {
      styleCtx = styleCtx || { bold: false, italic: false };

      if (n.nodeType === Node.TEXT_NODE) {
        const text = (n.nodeValue || '').replace(/\r/g, '');
        if (text.length) {
          // T√°ch theo \n ƒë·ªÉ tr√°nh ch·∫£y d√≤ng
          text.split('\n').forEach((seg, idx, arr) => {
            if (seg.length) {
              if (styleCtx.bold) tokens.push({ type: 'bold', text: seg });
              else if (styleCtx.italic) tokens.push({ type: 'italic', text: seg });
              else tokens.push({ type: 'text', text: seg });
            }
            // n·∫øu c√≥ nhi·ªÅu \n, ƒë·∫©y th√™m token r·ªóng ƒë·ªÉ gi·ªØ d√≤ng
            if (idx < arr.length - 1) tokens.push({ type: 'text', text: '' });
          });
        }
        return;
      }

      if (n.nodeType === Node.ELEMENT_NODE) {
        const tag = n.tagName?.toLowerCase();
        const nextCtx = { ...styleCtx };
        if (tag === 'b' || tag === 'strong') nextCtx.bold = true;
        if (tag === 'i' || tag === 'em') nextCtx.italic = true;
        n.childNodes.forEach(child => walk(child, nextCtx));
        return;
      }
    };

    walk(node, { bold: false, italic: false });
    return tokens;
  }

  // ƒêo t·ªïng width c·ªßa 1 d√≤ng token v·ªõi base fontPx
  function measureTokensWidth(ctx, tokens, fontPx) {
    let w = 0;
    tokens.forEach(tk => {
      const fontStyle = tk.type === 'italic' ? 'italic' : 'normal';
      const fontWeight = tk.type === 'bold' ? '700' : '400';
      ctx.font = `${fontStyle} ${fontWeight} ${fontPx}px system-ui, -apple-system, sans-serif`;
      w += ctx.measureText(tk.text).width;
    });
    return w;
  }

  // V·∫Ω 1 d√≤ng token theo (x, y)
  function drawTokensLine(ctx, tokens, x, y, fontPx, color) {
    let cursor = x;
    tokens.forEach(tk => {
      const fontStyle = tk.type === 'italic' ? 'italic' : 'normal';
      const fontWeight = tk.type === 'bold' ? '700' : '400';
      ctx.font = `${fontStyle} ${fontWeight} ${fontPx}px system-ui, -apple-system, sans-serif`;
      ctx.fillStyle = color;
      if (tk.text) {
        ctx.fillText(tk.text, cursor, y);
        cursor += ctx.measureText(tk.text).width;
      }
    });
  }

  // Sync khi g√µ: re-render
  ["input", "keyup", "change", "paste"].forEach(ev => {
    if (richText) richText.addEventListener(ev, sizeChange);
  });

  // ===== Wrap & fit =====
  function wrapLines(ctx, text, maxWidth) {
    const lines = [];
    const paragraphs = text.split("\n");

    for (const para of paragraphs) {
      if (para === "") {
        lines.push("");
        continue;
      }
      const words = para.split(/\s+/);
      let line = "";
      for (const w of words) {
        if (!w) continue;
        const test = line ? line + " " + w : w;
        if (ctx.measureText(test).width <= maxWidth) {
          line = test;
        } else {
          if (line) lines.push(line);
          line = w;
        }
      }
      if (line) lines.push(line);
    }
    return lines;
  }

  function computeFittedLines(text, boxPx, padding, lineH) {
    let fontPx = 20;
    const maxHeight = boxPx.h - padding * 2;
    let lines = [];

    while (fontPx >= 10) {
      ctx.font = `normal 400 ${fontPx}px system-ui, -apple-system, sans-serif`;
      const maxWidth = Math.max(0, boxPx.w - padding * 2);
      lines = wrapLines(ctx, text, maxWidth);

      const lh = lineH * fontPx;
      const totalH = lines.length * lh;

      if (totalH <= maxHeight) {
        return { fontPx, lines, lh };
      }
      fontPx--;
    }

    ctx.font = "normal 400 10px system-ui, -apple-system, sans-serif";
    const maxWidth = Math.max(0, boxPx.w - padding * 2);
    lines = wrapLines(ctx, text, maxWidth);
    return { fontPx: 10, lines, lh: lineH * 10 };
  }

  function drawRoundedRectPath(ctx, x, y, w, h, r) {
    const rr = Math.min(r, w / 2, h / 2);
    ctx.beginPath();
    ctx.moveTo(x + rr, y);
    ctx.arcTo(x + w, y, x + w, y + h, rr);
    ctx.arcTo(x + w, y + h, x, y + h, rr);
    ctx.arcTo(x, y + h, x, y, rr);
    ctx.arcTo(x, y, x + w, y, rr);
    ctx.closePath();
  }

  function updateOverlayButton() {
    if (!overlayToggleBtn || !overlayBtnText) return;

    if (hasOverlay) {
      overlayBtnText.innerHTML = '<i class="bi bi-x-lg"></i> G·ª° ·∫£nh';
      overlayToggleBtn.style.background = "linear-gradient(180deg, var(--brand-red), var(--brand-red-700))";
      overlayToggleBtn.style.color = "#fff";
      
      // Hi·ªÉn th·ªã crop controls
      if (cropControls) cropControls.style.display = "block";
    } else {
      overlayBtnText.innerHTML = '<i class="bi bi-camera-fill"></i> Ch·ªçn ·∫£nh';
      overlayToggleBtn.style.background = "var(--brand-beige-50)";
      overlayToggleBtn.style.color = "var(--brand-red-900)";
      
      // ·∫®n crop controls
      if (cropControls) cropControls.style.display = "none";
    }
  }

  // ================= RENDER =================
  function render(targetSize = BASE_SIZE, opts = {}) {
    if (!frameLoaded || !layoutLoaded || !currentLayout) return;

    const { forceHideBox = false } = opts;

    const textColor      = currentLayout.textColor        || "#333333";
    const imgBorderColor = currentLayout.imageBorderColor || "#000000";
    const textBoxColor   = currentLayout.textBoxColor     || "#22c55e";
    const imageBoxColor  = currentLayout.imageBoxColor    || "#38bdf8";

    const DPR = window.devicePixelRatio || 1;
    canvas.width = targetSize * DPR;
    canvas.height = targetSize * DPR;

    const zoom = parseInt(previewZoomEl?.value || "70", 10) / 100;
    canvas.style.width = targetSize * zoom + "px";
    canvas.style.height = "auto";

    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    ctx.clearRect(0, 0, targetSize, targetSize);

    // V·∫Ω frame (cover)
    const ir = frameImg.width / frameImg.height || 1;
    let w, h, x, y;
    if (ir > 1) {
      h = targetSize;
      w = h * ir;
      x = -(w - targetSize) / 2;
      y = 0;
    } else {
      w = targetSize;
      h = w / ir;
      x = 0;
      y = -(h - targetSize) / 2;
    }
    ctx.drawImage(frameImg, x, y, w, h);

    const textPx = boxPercentToPx(currentLayout.textBox, targetSize);
    const imagePx = boxPercentToPx(currentLayout.imageBox, targetSize);

    // ·∫¢nh overlay trong khung
    const rad = DEFAULT_OVERLAY_RADIUS;

    ctx.save();
    drawRoundedRectPath(ctx, imagePx.x, imagePx.y, imagePx.w, imagePx.h, rad);
    ctx.clip();

    // n·ªÅn tr·∫Øng m·∫∑c ƒë·ªãnh
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(imagePx.x, imagePx.y, imagePx.w, imagePx.h);

    if (overlayImg && hasOverlay) {
      // T√≠nh k√≠ch th∆∞·ªõc g·ªëc c·ªßa ·∫£nh d√πng cover mode (·∫£nh ph·ªß ƒë·∫ßy khung)
      const ir2 = overlayImg.width / overlayImg.height;
      const br = imagePx.w / imagePx.h;
      let initialW, initialH, initialX, initialY;

      if (ir2 > br) { // ·∫£nh r·ªông h∆°n khung
        initialH = imagePx.h;
        initialW = initialH * ir2;
        initialX = imagePx.x - (initialW - imagePx.w) / 2;
        initialY = imagePx.y;
      } else { // ·∫£nh cao h∆°n khung
        initialW = imagePx.w;
        initialH = initialW / ir2;
        initialX = imagePx.x;
        initialY = imagePx.y - (initialH - imagePx.h) / 2;
      }

      // √Åp d·ª•ng zoom (ph√≥ng to/thu nh·ªè t·ª´ t√¢m)
      const zoomedW = initialW * overlayZoom;
      const zoomedH = initialH * overlayZoom;
      const zoomCenterX = initialX + initialW / 2;
      const zoomCenterY = initialY + initialH / 2;

      // V·∫Ω ·∫£nh v·ªõi zoom v√† pan (k√©o)
      const drawX = zoomCenterX - zoomedW / 2 + overlayOffsetX;
      const drawY = zoomCenterY - zoomedH / 2 + overlayOffsetY;

      ctx.globalAlpha = DEFAULT_OVERLAY_ALPHA;
      ctx.drawImage(overlayImg, drawX, drawY, zoomedW, zoomedH);
    }

    ctx.restore();

    // vi·ªÅn khung ·∫£nh
    ctx.save();
    drawRoundedRectPath(ctx, imagePx.x, imagePx.y, imagePx.w, imagePx.h, rad);
    ctx.lineWidth = 6;
    ctx.strokeStyle = imgBorderColor;
    ctx.stroke();
    ctx.restore();

    // KHUNG DEBUG (t·∫Øt m·∫∑c ƒë·ªãnh)
    const showNow = false;
    if (showNow && !forceHideBox) {
      ctx.save();
      ctx.setLineDash([8, 6]);
      ctx.lineWidth = 2.5;

      ctx.strokeStyle = textBoxColor;
      ctx.strokeRect(textPx.x, textPx.y, textPx.w, textPx.h);

      ctx.strokeStyle = imageBoxColor;
      ctx.strokeRect(imagePx.x, imagePx.y, imagePx.w, imagePx.h);

      ctx.setLineDash([]);
      ctx.restore();
    }

    // ===== V·∫Ω text c√≥ inline style & align & bullet =====
    const padding = parseFloat(paddingEl?.value) || 0;

    let rawLH = parseFloat(lineHeightEl?.value);
    if (isNaN(rawLH)) rawLH = 1.0;
    const lineH = Math.max(0.8, rawLH);

    // L·∫•y lines t·ª´ HTML editor (g·ªìm tokens & c·ªù bullet)
    const richLines = serializeEditorToLines();

    // D√πng text plain ƒë·ªÉ ∆∞·ªõc l∆∞·ª£ng fontPx & line height ph√π h·ª£p khung
    const plain = richLines.map(r => r.tokens.map(t => t.text).join('')).join('\n');
    const fit = computeFittedLines(plain, textPx, padding, lineH);

    ctx.textBaseline = "top";
    ctx.fillStyle = currentLayout.textColor || "#333";

    const innerLeft = textPx.x + padding;
    const innerRight = textPx.x + textPx.w - padding;
    const innerWidth = innerRight - innerLeft;

    let ty = textPx.y + padding;
    const align = getEditorAlign();

    for (const row of richLines) {
      // H·ªó tr·ª£ c·∫£ 2 ki·ªÉu bullet: t·ª´ <li> ho·∫∑c t·ª´ k√Ω t·ª± '‚Ä¢ ' ƒë·∫ßu d√≤ng
      let isBullet = !!row.bullet;
      // N·∫øu ch∆∞a l√† bullet m√† token ƒë·∫ßu ch·ª©a '‚Ä¢ ', c≈©ng coi l√† bullet v√† b·ªè k√Ω t·ª± ƒë√≥ ƒëi
      if (!isBullet && row.tokens.length && typeof row.tokens[0].text === 'string' && /^\s*‚Ä¢\s+/.test(row.tokens[0].text)) {
        row.tokens[0].text = row.tokens[0].text.replace(/^\s*‚Ä¢\s+/, '');
        isBullet = true;
      }

      const bulletIndent = isBullet ? Math.min(16, fit.fontPx * 0.9) : 0;
      const bulletGap = isBullet ? Math.min(10, fit.fontPx * 0.5) : 0;

      // ƒêo width d√≤ng theo tokens ƒë·ªÉ canh l·ªÅ
      const tokensWidth = measureTokensWidth(ctx, row.tokens, fit.fontPx);
      const testWidth = tokensWidth + (isBullet ? bulletIndent + bulletGap : 0);

      let startX = innerLeft;
      if (align === 'center') startX = innerLeft + (innerWidth - testWidth) / 2;
      if (align === 'right')  startX = innerRight - testWidth;

      // V·∫Ω bullet n·∫øu c√≥
      let cursorX = startX;
      if (isBullet) {
        const r = Math.max(2, Math.round(fit.fontPx * 0.15));
        ctx.beginPath();
        ctx.arc(cursorX + r, ty + fit.fontPx * 0.5, r, 0, Math.PI * 2);
        ctx.fill();
        cursorX += bulletIndent + bulletGap;
      }

      // V·∫Ω tokens (ƒë·∫≠m/ nghi√™ng) theo th·ª© t·ª±
      drawTokensLine(ctx, row.tokens, cursorX, ty, fit.fontPx, currentLayout.textColor || "#333");

      ty += fit.lh;
      // N·∫øu v∆∞·ª£t qu√° khung text, d·ª´ng (tr√°nh v·∫Ω tr√†n)
      if (ty > textPx.y + textPx.h - padding) break;
    }
  }

  // ================= LOAD FRAMES FROM API =================
  const FRAME_API_BASE = "/api/frame-layout";
  const TEMPLATE_API_BASE = "/api/templates";

  async function loadFrameList() {
    const params = new URLSearchParams(window.location.search);
    const tplKey = params.get("tpl");             // template ƒë∆∞·ª£c ch·ªçn (n·∫øu c√≥)
    const frameKeyFromUrl = params.get("frame");  // optional: deep-link frame

    try {
      if (tplKey) {
        setStatus(`ƒêang t·∫£i frame c·ªßa template "${tplKey}"...`);
        const res = await fetch(`${TEMPLATE_API_BASE}/${encodeURIComponent(tplKey)}`);
        if (!res.ok) throw new Error("HTTP " + res.status);
        const data = await res.json();

        if (!data.frames || !data.frames.length) {
          setStatus("Template n√†y ch∆∞a c√≥ frame n√†o. H√£y c·∫•u h√¨nh frame_layouts v·ªõi template_id t∆∞∆°ng ·ª©ng.", true);
          frameSelect.innerHTML = "";
          return;
        }

        frames = data.frames; // [{layout_key, frame_url}, ...]
        frameSelect.innerHTML = "";
        frames.forEach(f => {
          const opt = document.createElement("option");
          opt.value = f.layout_key;
          opt.textContent = f.layout_key;
          frameSelect.appendChild(opt);
        });

        const initialKey = (frameKeyFromUrl && frames.some(f => f.layout_key === frameKeyFromUrl))
          ? frameKeyFromUrl
          : frames[0].layout_key;

        currentKey = initialKey;
        frameSelect.value = currentKey;

        await loadLayout(currentKey);
        setStatus(`Template: ${data.name || tplKey} ‚Ä¢ ƒêang d√πng frame "${currentKey}"`);
        return;
      }

      // Fallback: l·∫•y t·∫•t c·∫£ frame
      setStatus("ƒêang t·∫£i danh s√°ch frame...");

      const res = await fetch(FRAME_API_BASE);
      if (!res.ok) throw new Error("HTTP " + res.status);
      const list = await res.json();

      if (!list.length) {
        setStatus("Ch∆∞a c√≥ frame n√†o trong h·ªá th·ªëng.", true);
        frameSelect.innerHTML = "";
        return;
      }

      frames = list; // [{layout_key, ...}, ...]
      frameSelect.innerHTML = "";
      frames.forEach(f => {
        const opt = document.createElement("option");
        opt.value = f.layout_key;
        opt.textContent = f.layout_key;
        frameSelect.appendChild(opt);
      });

      const initialKey = (frameKeyFromUrl && frames.some(f => f.layout_key === frameKeyFromUrl))
        ? frameKeyFromUrl
        : frames[0].layout_key;

      currentKey = initialKey;
      frameSelect.value = currentKey;

      await loadLayout(currentKey);
      setStatus(`ƒêang d√πng frame "${currentKey}"`);
    } catch (err) {
      console.error(err);
      setStatus("Kh√¥ng load ƒë∆∞·ª£c danh s√°ch frame.", true);
    }
  }

  async function loadLayout(key) {
    layoutLoaded = false;
    frameLoaded = false;
    overlayImg = null;
    hasOverlay = false;

    if (overlayInput) overlayInput.value = "";
    updateOverlayButton();

    // --- Reset tr·∫°ng th√°i Overlay ---
    overlayZoom = 1.0;
    overlayOffsetX = 0;
    overlayOffsetY = 0;
    if (imageZoomEl) {
      imageZoomEl.value = 100;
      if (zoomImageLabel) zoomImageLabel.textContent = "100";
    }

    setStatus("ƒêang t·∫£i layout " + key + "...");
    try {
      const res = await fetch(`/api/frame-layout/${encodeURIComponent(key)}`);
      if (!res.ok) throw new Error("HTTP " + res.status);
      const data = await res.json();

      currentLayout = {
        frame_url: data.frame_url,
        textBox: data.textBox,
        imageBox: data.imageBox,
        textColor: data.textColor || "#333333",
        imageBorderColor: data.imageBorderColor || "#000000",
        textBoxColor: data.textBoxColor || "#22c55e",
        imageBoxColor: data.imageBoxColor || "#38bdf8",
      };

      await loadFrameImage(currentLayout.frame_url);
      layoutLoaded = true;
      setStatus(`ƒê√£ t·∫£i frame "${key}". Nh·∫≠p n·ªôi dung & ch·ªçn ·∫£nh.`);
      sizeChange();
    } catch (err) {
      console.error(err);
      setStatus("Kh√¥ng load ƒë∆∞·ª£c layout/frame.", true);
    }
  }

  function loadFrameImage(url) {
    return new Promise((resolve) => {
      frameImg = new Image();
      frameImg.onload = () => {
        frameLoaded = true;
        resolve();
      };
      frameImg.onerror = () => {
        setStatus("Kh√¥ng load ƒë∆∞·ª£c frame_url: " + url, true);
        resolve();
      };
      frameImg.src = url;
    });
  }

  // ================= EVENTS =================
  // ch·ªçn frame kh√°c
  safeAddListener(frameSelect, "change", async () => {
    const key = frameSelect.value;
    if (!key) return;
    currentKey = key;
    await loadLayout(currentKey);
    sizeChange();
  });

  if (richText) {
    ['input','keyup','change','paste'].forEach(ev =>
      richText.addEventListener(ev, sizeChange)
    );
  }

  // auto render khi thay ƒë·ªïi text / lineHeight / padding / exportSize
  ["input", "change"].forEach((ev) => {
    safeAddListener(textInput, ev, sizeChange);
    safeAddListener(lineHeightEl, ev, sizeChange);
    safeAddListener(paddingEl, ev, sizeChange);
    safeAddListener(exportSizeEl, ev, sizeChange);
  });

  // zoom preview
  if (previewZoomEl && zoomLabel) {
    const handleZoom = () => {
      zoomLabel.textContent = previewZoomEl.value;
      sizeChange();
    };
    previewZoomEl.addEventListener("input", handleZoom);
    previewZoomEl.addEventListener("change", handleZoom);
  }

  // zoom image overlay
  if (imageZoomEl && zoomImageLabel) {
    const handleImageZoom = () => {
      const zoomPercent = parseInt(imageZoomEl.value, 10);
      zoomImageLabel.textContent = zoomPercent;
      overlayZoom = zoomPercent / 100;
      // Clamp offset khi zoom thay ƒë·ªïi (v√¨ gi·ªõi h·∫°n thay ƒë·ªïi theo zoom)
      clampImageOffset();
      sizeChange();
    };
    imageZoomEl.addEventListener("input", handleImageZoom);
    imageZoomEl.addEventListener("change", handleImageZoom);
  }

  // n√∫t reset ·∫£nh
  safeAddListener(resetImageBtn, "click", () => {
    // Reset zoom v·ªÅ 100%
    if (imageZoomEl) {
      imageZoomEl.value = 100;
      overlayZoom = 1.0;
      if (zoomImageLabel) zoomImageLabel.textContent = "100";
    }
    // Reset offset v·ªÅ (0, 0)
    overlayOffsetX = 0;
    overlayOffsetY = 0;
    sizeChange();
  });

  // n√∫t ch·ªçn / g·ª° ·∫£nh
  safeAddListener(overlayToggleBtn, "click", () => {
    if (hasOverlay) {
      overlayImg = null;
      hasOverlay = false;
      if (overlayInput) overlayInput.value = "";
      updateOverlayButton();
      sizeChange();
    } else {
      if (overlayInput) overlayInput.click();
    }
  });

  // upload ·∫£nh overlay
  safeAddListener(overlayInput, "change", (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = () => {
      const img = new Image();
      img.onload = () => {
        overlayImg = img;
        hasOverlay = true;
        // Reset offset v·ªÅ 0 khi upload ·∫£nh m·ªõi (·∫£nh s·∫Ω ·ªü v·ªã tr√≠ m·∫∑c ƒë·ªãnh)
        overlayOffsetX = 0;
        overlayOffsetY = 0;
        updateOverlayButton();
        sizeChange();
      };
      img.src = reader.result;
    };
    reader.readAsDataURL(file);
  });

  // ================= DRAG TO PAN IMAGE =================
  let isDragging = false;
  let dragStartX = 0;
  let dragStartY = 0;
  let dragStartOffsetX = 0;
  let dragStartOffsetY = 0;

  // H√†m t√≠nh gi·ªõi h·∫°n offset ƒë·ªÉ ·∫£nh kh√¥ng k√©o ra ngo√†i khung
  function clampImageOffset(targetSize = BASE_SIZE) {
    if (!overlayImg || !currentLayout) return;

    const imagePx = boxPercentToPx(currentLayout.imageBox, targetSize);
    const ir2 = overlayImg.width / overlayImg.height;
    const br = imagePx.w / imagePx.h;
    
    // T√≠nh k√≠ch th∆∞·ªõc ban ƒë·∫ßu (cover mode)
    let initialW, initialH;
    if (ir2 > br) {
      initialH = imagePx.h;
      initialW = initialH * ir2;
    } else {
      initialW = imagePx.w;
      initialH = initialW / ir2;
    }

    // K√≠ch th∆∞·ªõc sau khi zoom
    const zoomedW = initialW * overlayZoom;
    const zoomedH = initialH * overlayZoom;

    // T√≠nh gi·ªõi h·∫°n offset
    // N·∫øu ·∫£nh l·ªõn h∆°n khung: c√≥ th·ªÉ k√©o trong ph·∫°m vi
    // N·∫øu ·∫£nh nh·ªè h∆°n khung: kh√¥ng th·ªÉ k√©o (offset = 0)
    
    let minOffsetX, maxOffsetX;
    if (zoomedW > imagePx.w) {
      // ·∫¢nh l·ªõn h∆°n khung: c√≥ th·ªÉ k√©o
      maxOffsetX = (zoomedW - imagePx.w) / 2;
      minOffsetX = -maxOffsetX;
    } else {
      // ·∫¢nh nh·ªè h∆°n khung: kh√¥ng th·ªÉ k√©o, ph·∫£i ·ªü gi·ªØa
      minOffsetX = 0;
      maxOffsetX = 0;
    }

    let minOffsetY, maxOffsetY;
    if (zoomedH > imagePx.h) {
      // ·∫¢nh l·ªõn h∆°n khung: c√≥ th·ªÉ k√©o
      maxOffsetY = (zoomedH - imagePx.h) / 2;
      minOffsetY = -maxOffsetY;
    } else {
      // ·∫¢nh nh·ªè h∆°n khung: kh√¥ng th·ªÉ k√©o, ph·∫£i ·ªü gi·ªØa
      minOffsetY = 0;
      maxOffsetY = 0;
    }

    // Clamp offset v·ªÅ trong gi·ªõi h·∫°n
    overlayOffsetX = Math.max(minOffsetX, Math.min(maxOffsetX, overlayOffsetX));
    overlayOffsetY = Math.max(minOffsetY, Math.min(maxOffsetY, overlayOffsetY));
  }

  const canvasWrap = document.querySelector('.canvas-wrap');
  if (canvasWrap) {
    canvasWrap.addEventListener('mousedown', (e) => {
      if (!hasOverlay || !currentLayout) return;
      
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      dragStartOffsetX = overlayOffsetX;
      dragStartOffsetY = overlayOffsetY;
      canvasWrap.style.cursor = 'grabbing';
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;

      // T√≠nh to√°n delta d·ª±a tr√™n preview zoom level
      const previewZoom = parseInt(previewZoomEl?.value || "70", 10) / 100;
      const canvasDisplayWidth = 520 * previewZoom;
      const scale = BASE_SIZE / canvasDisplayWidth;

      const deltaX = (e.clientX - dragStartX) * scale;
      const deltaY = (e.clientY - dragStartY) * scale;

      // C·∫≠p nh·∫≠t offset t·∫°m th·ªùi
      overlayOffsetX = dragStartOffsetX + deltaX;
      overlayOffsetY = dragStartOffsetY + deltaY;

      // Gi·ªõi h·∫°n offset trong v√πng khung ·∫£nh
      clampImageOffset();

      sizeChange();
    });

    document.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        canvasWrap.style.cursor = 'grab';
      }
    });

    canvasWrap.addEventListener('mouseenter', () => {
      if (hasOverlay && !isDragging) {
        canvasWrap.style.cursor = 'grab';
      }
    });

    canvasWrap.addEventListener('mouseleave', () => {
      canvasWrap.style.cursor = 'default';
    });
  }

  // download: desktop t·∫£i file, mobile/in-app m·ªü JPEG ƒë·ªÉ gi·ªØ-l∆∞u
  safeAddListener(downloadBtn, "click", () => {
    if (!frameLoaded || !layoutLoaded || !currentLayout) return;

    const size = parseInt(exportSizeEl?.value || "1080", 10);
    const fileName = `${currentKey || "frame"}_export.jpg`;

    // v·∫Ω b·∫£n s·∫°ch
    render(size, { forceHideBox: true });

    const ua = navigator.userAgent || "";
    const isIOS    = /iP(hone|od|ad)/i.test(ua);
    const isSafari = /^((?!chrome|android).)*safari/i.test(ua);
    const isInApp  = /(FBAN|FBAV|FB_IAB|FB4A|Instagram|Messenger)/i.test(ua);

    // xu·∫•t JPEG cho mobile/in-app
    const dataUrlJpeg = canvas.toDataURL("image/jpeg", 0.92);

    // In-app (Messenger / FB / IG): m·ªü trang ch·ªâ c√≥ ·∫£nh
    if (isInApp) {
      const html =
        '<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width,initial-scale=1">' +
        '<title>L∆∞u ·∫£nh</title></head>' +
        '<body style="margin:0;background:#000;display:flex;align-items:center;justify-content:center;">' +
        '<img src="' + dataUrlJpeg + '" style="max-width:100%;height:auto;display:block;" />' +
        '</body></html>';

      const win = window.open();
      if (win) {
        win.document.open();
        win.document.write(html);
        win.document.close();
      } else {
        document.open();
        document.write(html);
        document.close();
      }
      sizeChange();
      return;
    }

    // iOS Safari: m·ªü ·∫£nh ri√™ng ƒë·ªÉ long-press l∆∞u
    if (isIOS && isSafari) {
      const win = window.open();
      if (win) {
        win.document.open();
        win.document.write(
          '<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width,initial-scale=1">' +
          '<title>L∆∞u ·∫£nh</title></head>' +
          '<body style="margin:0;background:#000;display:flex;align-items:center;justify-content:center;">' +
          '<img src="' + dataUrlJpeg + '" style="max-width:100%;height:auto;display:block;" />' +
          '</body></html>'
        );
        win.document.close();
      } else {
        window.location.href = dataUrlJpeg;
      }
      sizeChange();
      return;
    }

    // Desktop + ƒëa s·ªë Android browser: t·∫£i file b√¨nh th∆∞·ªùng
    canvas.toBlob((blob) => {
      if (!blob) return;
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      sizeChange();
    });
  });

  // ================= INIT =================
  function sizeChange() {
    // Render preview theo k√≠ch th∆∞·ªõc g·ªëc BASE_SIZE
    render(BASE_SIZE);
  }

  (async function init() {
    updateOverlayButton();
    setStatus("ƒêang t·∫£i danh s√°ch frame...");
    await loadFrameList();

    if (document.fonts && document.fonts.ready) {
      document.fonts.ready.then(sizeChange);
    } else {
      sizeChange();
    }

    window.addEventListener("resize", sizeChange);
  })();
</script>




</body>
</html>
