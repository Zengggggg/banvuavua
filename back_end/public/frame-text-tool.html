<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes" />
  <title>Frame Text Tool</title>
  <link rel="icon" href="Logo.jpg" type="image/x-icon">  
  
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css"
  />
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap');

    :root{
      /* ===== Brand palette (Red + Beige are primary) ===== */
      --brand-red:        #DC2626;   /* primary red */
      --brand-red-700:    #B91C1C;   /* hover/depth */
      --brand-red-900:    #7F1D1D;   /* strong accent */
      --brand-beige:      #F4E8D8;   /* primary beige (page bg) */
      --brand-beige-200:  #EFE0CC;   /* panels */
      --brand-beige-300:  #E8D6C0;   /* inputs */
      --brand-beige-50:   #FBF6EE;   /* soft highlights */
      --ink:              #1A1A1A;   /* text (secondary color) */
      --border:           rgba(185,28,28,0.25);  /* red-tinted border */
      --border-soft:      rgba(185,28,28,0.15);
      --shadow:           rgba(185,28,28,0.22);
    }

    /* ===== Page layout ===== */
    body{
      margin:0; padding:16px;
      font-family: 'Montserrat', system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      color: var(--ink);
      min-height:100vh;
      display:flex; flex-direction:column; align-items:center; gap:12px;
      box-sizing:border-box;
    }

    /* Wrap your main two columns if you have them */
    .sidebar{
      width:320px;
      padding:18px;
      border-right:1px solid var(--border-soft);
      background:
        linear-gradient(180deg, var(--brand-beige-50), var(--brand-beige-200));
      display:flex; flex-direction:column; gap:12px;
      box-sizing:border-box;
      border-radius:14px;
      box-shadow: 0 10px 30px var(--shadow);
    }

    .main{
      flex:1;
      display:flex;
      align-items:center; justify-content:center;
      padding:18px; box-sizing:border-box;
    }

    .canvas-wrap{
      padding:16px;
      border-radius:24px;
      background:
        linear-gradient(180deg, var(--brand-beige-50), var(--brand-beige-200));
      border:1px solid var(--border);
      box-shadow: 0 24px 70px var(--shadow);
    }

    canvas{
      display:block;
      width:520px; height:520px;
      border-radius:18px;
      background: var(--brand-beige-50);  /* kh√¥ng c√≤n n·ªÅn ƒëen */
      border:1px solid var(--border-soft);
    }

    /* ===== Typography ===== */
    .tag {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-weight: 600;
      color: var(--brand-red-900);
    }

    .tag i {
      font-size: 1.1em;
      color: var(--brand-red);
    }
    h1{
      margin:0 0 6px 0;
      font-size:18px; font-weight:800;
      color: var(--brand-red);            /* ti√™u ƒë·ªÅ ƒë·ªè */
    }
    p, .status{ margin:0; font-size:12px; color:#6b5346; }

    label{
      font-size:12px; color:#7a5c4b;
      margin-bottom:4px; display:block;
    }

    /* ===== Inputs ===== */
    select, textarea, input[type="text"], input[type="number"]{
      width:100%; padding:8px 10px;
      border-radius:12px;
      border:1px solid var(--border);
      background: var(--brand-beige-300);
      color: var(--ink); font-size:12px;
      outline:none; box-sizing:border-box;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.35);
    }
    input[type="range"]{ width:100%; accent-color: var(--brand-red); }

    select:focus, textarea:focus, input[type="text"]:focus, input[type="number"]:focus{
      border-color: var(--brand-red-700);
      box-shadow: 0 0 0 3px rgba(220,38,38,0.20);
    }

    .row{ display:flex; gap:8px; align-items:center; justify-content:space-between; }
    .row label{ margin:0; }

    .template-editor{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-bottom:12px;
    }
    .template-field{
      border:1px solid var(--border-soft);
      border-radius:12px;
      padding:10px;
      background: var(--brand-beige-50);
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .template-field p{
      margin:0;
      font-size:12px;
      color:#6b5346;
      font-weight:600;
    }
    .template-field input{
      border-radius:10px;
      border:1px dashed rgba(185,28,28,0.45);
      background: var(--brand-beige-300);
      padding:8px 10px;
      font-size:12px;
      color: var(--ink);
      outline:none;
    }
    .template-field input::placeholder{
      color:#967a67;
    }

    /* ===== Buttons ===== */
    .btn{
      padding:8px 14px; border-radius:999px;
      border:1px solid var(--brand-red-700);
      background: linear-gradient(180deg, var(--brand-red), var(--brand-red-700));
      color: #FFF7F0; font-size:12px; font-weight:800;
      cursor:pointer; display:inline-flex; align-items:center; gap:6px;
      text-transform: uppercase; letter-spacing: .02em;
      box-shadow: 0 12px 28px rgba(220,38,38,0.35);
      transition: transform .15s ease, box-shadow .15s ease, filter .15s ease;
    }
    .btn:hover{
      transform: translateY(-1px);
      box-shadow: 0 16px 36px rgba(220,38,38,0.45);
      filter: brightness(1.05);
    }

    /* ===== Upload (beige primary secondary to red) ===== */
    .upload-wrapper{
      display: flex;
      flex-direction: column;
      gap: 6px;
      align-items: center;        /* <-- cƒÉn gi·ªØa to√†n b·ªô trong wrapper */
      text-align: center;
    }
    .upload-btn{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 14px; border-radius:999px; cursor:pointer;
      border:1px solid var(--border);
      background: var(--brand-beige-50);
      color: var(--ink);
      font-size:12px; font-weight:700;
      box-shadow: 0 6px 14px rgba(220,38,38,0.18);
      transition: transform .15s ease, box-shadow .15s ease, background .15s ease;
    }
    .upload-btn:hover{
      transform: translateY(-1px);
      background: var(--brand-beige);
      box-shadow: 0 10px 22px rgba(220,38,38,0.28);
    }
    .upload-icon{ font-size:14px; }
    .upload-hint{ font-size:11px; color:#7a5c4b; }

    /* === Layout fix: sidebar tr√°i, canvas ph·∫£i + 1 ·∫£nh background === */
    body {
      display: flex;
      flex-direction: row;
      align-items: flex-start;
      gap: 16px;

      background-image: url('background2.svg');
      background-size: cover;         /* fill to√†n m√†n */
      background-repeat: no-repeat;   /* kh√¥ng l·∫∑p */
      background-position: center;    /* cƒÉn gi·ªØa */

      flex-wrap: wrap;
      min-height: 100vh;              /* tr√°nh body co l·∫°i l√†m ·∫£nh g·∫•p */
    }

    /* Sidebar c·ªë ƒë·ªãnh b·ªÅ r·ªông v√† d√≠nh b√™n tr√°i */
    .sidebar{
      width: 320px;                  /* b·ªÅ r·ªông c·ªôt tr√°i */
      flex: 0 0 320px;               /* kh√¥ng co gi√£n */
      height: calc(100vh - 32px);    /* tr·ª´ padding body 16px tr√™n/d∆∞·ªõi */
      position: sticky;              /* d√≠nh khi cu·ªôn */
      top: 16px;
      overflow: auto;                /* cu·ªôn n·ªôi dung n·∫øu d√†i */
      box-sizing: border-box;
      -ms-overflow-style: none;  /* IE/Edge c≈© */
      scrollbar-width: none;     /* Firefox */
    }
    .sidebar::-webkit-scrollbar{ /* Chrome/Safari/Opera */
      width: 0;
      height: 0;
    }

    /* Khu v·ª±c ch√≠nh chi·∫øm ph·∫ßn c√≤n l·∫°i */
    .main{
      flex: 1 1 auto;                /* gi√£n h·∫øt ph·∫ßn c√≤n l·∫°i */
      min-width: 0;                  /* tr√°nh overflow ngang khi c√≥ canvas to */
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* ƒê·∫£m b·∫£o canvas √¥m v·ª´a, kh√¥ng tr√†n */
    .canvas-wrap{
      max-width: 100%;
    }
    canvas{
      max-width: 100%;
      height: auto;
    }

    /* === Responsive: d∆∞·ªõi 900px th√¨ x·∫øp d·ªçc nh∆∞ mobile (sidebar ph√≠a tr√™n) === */
    @media (max-width: 900px){
      body{
        flex-direction: column;      /* mobile gi·ªØ d·ªçc */
        align-items: stretch;
      }
      .sidebar{
        position: static;
        width: 100%;
        height: auto;
      }
      .main{
        width: 100%;
        justify-content: center;
      }
    }

    /* ===== Header (ƒë·ªè & be l√† ch·ªß ƒë·∫°o) ===== */
    .app-header{
      flex: 0 0 100%;
      order: -1;
      align-self: stretch;
      width: 100%;
      top: 0; z-index: 1000;
      display: grid;
      grid-template-columns: 1fr auto 1fr; /* tr√°i | gi·ªØa | ph·∫£i */
      align-items: center;
      gap: 12px;

      padding: 10px 14px;
      margin-bottom: 12px;
      border: 1px solid var(--border);
      border-radius: 14px;

      background: linear-gradient(180deg, var(--brand-beige-50), var(--brand-beige-200));
      box-shadow: 0 10px 26px var(--shadow);
    }

    /* C·ªôt tr√°i/gi·ªØa/ph·∫£i */
    .header-left{ display:flex; align-items:center; gap:10px; }
    .header-center{ display:flex; justify-content:center; }
    .header-right{
      display:flex; justify-content:flex-end; align-items:center; gap:10px;
    }

    /* Back icon-only */
    .back-icon{
      display:inline-flex; align-items:center; justify-content:center;
      width: 36px; height: 36px; border-radius: 999px;
      background: var(--brand-beige-50);
      color: var(--brand-red-900);
      border: 1px solid var(--border);
      box-shadow: 0 6px 16px rgba(220,38,38,.18);
      text-decoration: none;
      transition: transform .15s ease, background .15s ease, color .15s ease, box-shadow .15s ease;
    }
    .back-icon:hover{
      background: var(--brand-red); /* n·ªÅn ƒë·ªè khi hover */
      color: white; /* m≈©i t√™n tr·∫Øng */
      box-shadow: 0 10px 24px rgba(220,38,38,.35);
      transform: translateY(-1px);
    }

    /* Ti√™u ƒë·ªÅ trung t√¢m */
    .brand-title{
      margin:0; font-size:14px; font-weight:900; letter-spacing:.02em;
      color: var(--brand-red-900);
    }

    /* N√∫t MXH */
    .social-btn{
      display:inline-flex; align-items:center; justify-content:center;
      width:34px; height:34px; border-radius:10px;
      color: var(--brand-red-900); background: var(--brand-beige-50);
      border:1px solid var(--border);
      transition: transform .15s ease, background .15s ease, color .15s ease;
    }
    .social-btn:hover{
      transform: translateY(-1px);
      background:#FBE9E7; color: var(--brand-red-700);
    }

    /* D·ªãch icon MXH sang tr√°i m·ªôt ch√∫t */
    .header-right {
      justify-content: flex-end;
      gap: 8px;
      margin-right: 60px;
      transform: translateX(-8px);
    }

    /* Responsive: d∆∞·ªõi 900px - layout d·ªçc + t·ªëi ∆∞u mobile */
    @media (max-width: 900px){
      body{
        display: flex;
        flex-direction: column;
        padding: 8px;
        gap: 16px;
        min-height: 100dvh;
        background: url('background2.png');
        background-size: cover;
        background-repeat: no-repeat;
        background-position: center;
      }

      .app-header{
        position: sticky;
        top: 0;
        z-index: 1000;
        margin-bottom: 0;
        border-radius: 10px;
      }

      .sidebar{
        flex: 0 1 auto;
        width: 100%;
        max-height: 50vh;
        overflow-y: auto;
        overflow-x: hidden;
        padding: 14px;
        border-radius: 12px;
        position: relative;
        -webkit-overflow-scrolling: touch;
        margin-bottom: 8px;
      }

      .sidebar::-webkit-scrollbar{
        width: 6px;
      }

      .sidebar::-webkit-scrollbar-thumb{
        background: var(--brand-red);
        border-radius: 3px;
      }

      /* Main: Canvas area */
      .main{
        flex: 1 1 auto;
        min-height: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 8px;
        overflow: hidden;
      }

      .canvas-wrap{
        width: 100%;
        max-width: 100%;
        padding: 8px;
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      canvas{
        width: 100% !important;
        max-width: 100%;
        height: auto !important;
        touch-action: pan-x pan-y;
      }

      /* Typography - d·ªÖ ƒë·ªçc h∆°n */
      h1{
        font-size: 16px;
        margin-bottom: 8px;
      }

      p, .status{
        font-size: 13px;
      }

      label{
        font-size: 14px;
        margin-bottom: 6px;
        font-weight: 600;
      }

      /* Inputs - touch targets l·ªõn h∆°n */
      select, textarea, input[type="text"], input[type="number"]{
        font-size: 16px;
        padding: 12px 14px;
        min-height: 44px;
        border-radius: 10px;
      }

      input[type="range"]{
        min-height: 44px;
        padding: 8px 0;
      }

      /* Buttons - d·ªÖ b·∫•m h∆°n */
      .btn{
        font-size: 14px;
        padding: 14px 20px;
        min-height: 48px;
        border-radius: 12px;
        width: 100%;
        justify-content: center;
      }

      .upload-btn{
        font-size: 14px;
        padding: 14px 20px;
        min-height: 48px;
        width: 100%;
        justify-content: center;
      }

      /* Row layout - stack tr√™n mobile */
      .row{
        flex-direction: column;
        gap: 12px;
      }

      .row > div{
        width: 100%;
      }

      /* Upload wrapper */
      .upload-wrapper{
        gap: 10px;
      }

      .upload-hint{
        font-size: 12px;
      }

      /* Crop controls */
      #cropControls{
        padding-top: 16px;
        gap: 12px;
      }

      #cropControls .row{
        flex-direction: column;
      }

      #resetImageBtn{
        min-height: 48px;
        font-size: 14px;
      }

      /* Status text */
      .status{
        font-size: 12px;
        margin-top: 6px;
      }

      /* Card spacing */
      .card{
        padding: 14px;
        margin-bottom: 12px;
      }

      /* Select dropdown */
      select{
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23DC2626' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 14px center;
        padding-right: 40px;
        appearance: none;
        -webkit-appearance: none;
        -moz-appearance: none;
      }
    }

    /* Mobile nh·ªè h∆°n (d∆∞·ªõi 480px) */
    @media (max-width: 480px){
      body{
        padding: 6px;
        gap: 12px;
      }

      .sidebar{
        padding: 12px;
        max-height: 45vh;
        margin-bottom: 6px;
      }

      .app-header{
        padding: 6px 8px;
      }

      h1{
        font-size: 15px;
      }

      .btn, .upload-btn{
        padding: 12px 16px;
        font-size: 13px;
      }
    }
  </style>
</head>
<body>
  <header class="app-header">
    <div class="header-left">
      <a class="back-icon" href="/template-select.html" title="Quay l·∫°i trang ch·ªçn template" aria-label="Quay l·∫°i trang ch·ªçn template">
        <!-- Arrow Left -->
        <svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true">
          <path fill="currentColor" d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2Z"/>
        </svg>
      </a>
    </div>

    <div class="header-center">
      <h1 class="brand-title"></h1>
    </div>

    <nav class="header-right" aria-label="Social links">
      <a class="social-btn" href="https://www.facebook.com/banstudioHN" target="_blank" rel="noopener">
        <!-- Facebook -->
        <svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true">
          <path fill="currentColor" d="M22 12.07C22 6.48 17.52 2 11.93 2S2 6.48 2 12.07c0 5.02 3.66 9.18 8.44 9.93v-7.03H7.9v-2.9h2.54V9.41c0-2.5 1.49-3.88 3.77-3.88 1.09 0 2.23.2 2.23.2v2.45h-1.26c-1.24 0-1.62.77-1.62 1.56v1.87h2.76l-.44 2.9h-2.32V22c4.78-.75 8.44-4.91 8.44-9.93Z"/>
        </svg>
      </a>
      <a class="social-btn" href="https://www.instagram.com/banvaii/" target="_blank" rel="noopener">
        <!-- Instagram -->
        <svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true">
          <path fill="currentColor" d="M7 2h10a5 5 0 0 1 5 5v10a5 5 0 0 1-5 5H7a5 5 0 0 1-5-5V7a5 5 0 0 1 5-5Zm0 2a3 3 0 0 0-3 3v10a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3V7a3 3 0 0 0-3-3H7Zm5 3.5A5.5 5.5 0 1 1 6.5 13 5.5 5.5 0 0 1 12 7.5Zm0 2A3.5 3.5 0 1 0 15.5 13 3.5 3.5 0 0 0 12 9.5ZM18 6.2a1 1 0 1 0 1 1 1 1 0 0 0-1-1Z"/>
        </svg>
      </a>
      <a class="social-btn" href="https://www.tiktok.com/@aobanvai" target="_blank" rel="noopener">
        <!-- TikTok -->
        <svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true">
          <path fill="currentColor" d="M14.5 3.1v8.2a3.9 3.9 0 1 1-3.9-3.9c.2 0 .5 0 .7.1V5.06a7.02 7.02 0 0 0-.7-.04A6.94 6.94 0 1 0 17.54 12V9.58a7.2 7.2 0 0 0 4.46 1.52V8.1a4.7 4.7 0 0 1-4.46-5Z"/>
        </svg>
      </a>
    </nav>
  </header>

  <div class="sidebar">
    <div>
      <h1>Frame Text Tool</h1>
      <p>Ch·ªçn frame, nh·∫≠p n·ªôi dung, ch·ªçn ·∫£nh. V·ªã tr√≠ khung ƒë√£ ƒë∆∞·ª£c c·ªë ƒë·ªãnh.</p>
    </div>

    <div>
      <label>Ch·ªçn frame</label>
      <select id="frameSelect"></select>
      <div class="status" id="statusText">ƒêang t·∫£i danh s√°ch frame...</div>
    </div>

    <div class="template-editor">
      <label for="templateBusy">M·∫´u tr·∫£ l·ªùi c·ªë ƒë·ªãnh</label>

      <div class="template-field">
        <p>H√¥m nay t√¥i ‚Äúb·∫≠n‚Äù ki·ªÉu __________________</p>
        <input id="templateBusy" data-template-input type="text" placeholder="V√≠ d·ª•: chill l·∫∑ng l·∫Ω" />
      </div>

      <div class="template-field">
        <p>T√≠nh c√°ch - c·∫£m x√∫c ƒë√≥ th·ªÉ hi·ªán r√µ nh·∫•t khi __________</p>
        <input id="templateHighlight" data-template-input type="text" placeholder="V√≠ d·ª•: ƒëi d·∫°o cu·ªëi ng√†y" />
      </div>

      <div class="template-field">
        <p>Tuy ƒë√¥i khi t√¥i th·∫•y m√¨nh __________________ nh∆∞ng ƒë√≥ v·∫´n l√† t√¥i.</p>
        <input id="templateSometimes" data-template-input type="text" placeholder="V√≠ d·ª•: h∆°i th·∫•t th∆∞·ªùng" />
      </div>

      <div class="template-field">
        <p>T√¥i nghƒ© ƒëi·ªÅu khi·∫øn t√¥i kh√°c bi·ªát l√† __________________</p>
        <input id="templateUnique" data-template-input type="text" placeholder="V√≠ d·ª•: lu√¥n ch√¢n th√†nh v·ªõi c·∫£m x√∫c" />
      </div>

      <div class="template-field">
        <p>ƒê·ªÉ m√¥ t·∫£ t√≠nh c√°ch - c·∫£m x√∫c ƒë√≥ v·ªõi 3 t·ª´ kh√°c nhau th√¨ s·∫Ω l√† __________________</p>
        <input id="templateThreeWords" data-template-input type="text" placeholder="V√≠ d·ª•: d·ªãu d√†ng - s√¢u s·∫Øc - ·∫•m √°p" />
      </div>

      <div class="template-field">
        <p>B·∫°n th·∫•y ___________ c√≥ b·ªôc l·ªô v√† th·ªÉ hi·ªán ƒë∆∞·ª£c t√≠nh c√°ch - c·∫£m x√∫c ch√≠nh c·ªßa b·∫°n? </p>
        <input id="templateColor" data-template-input type="text" placeholder="V√≠ d·ª•: xanh ve chai" />
      </div>

      <div class="template-field">
        <p>B·∫°n c√≥ c·∫£m th·∫•y l·ª±a ch·ªçn n√†y th·ªÉ hi·ªán ƒë√∫ng t√≠nh c√°ch v√† c·∫£m x√∫c ch√≠nh c·ªßa b·∫°n kh√¥ng?</p>
        <select id="templateAnswer" data-template-input>
          <option value="" disabled selected>Ch·ªçn c√¢u tr·∫£ l·ªùi</option>
          <option value="C√≥">C√≥</option>
          <option value="Maybe">Maybe</option>
          <option value="Kh√¥ng">Kh√¥ng</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div style="flex:1">
        <label>Gi√£n d√≤ng</label>
        <input id="lineHeight" type="number" step="0.1" min="0.8" max="2.0" value="1.2" />
      </div>
      <div style="flex:1">
        <label>Padding (px)</label>
        <input id="padding" type="number" min="0" max="80" value="10" />
      </div>
    </div>

    <div class="row">
      <div style="flex:1">
        <label>K√≠ch th∆∞·ªõc xu·∫•t (px)</label>
        <input id="exportSize" type="number" min="600" max="2000" step="60" value="1080" />
      </div>
      <div style="flex:1">
        <label>Zoom xem tr∆∞·ªõc (<span id="zoomLabel">70</span>%)</label>
        <input id="previewZoom" type="range" min="30" max="120" step="5" value="70" />
      </div>
    </div>
    
    <div class="upload-wrapper">
      <label>·∫¢nh c·ªßa b·∫°n</label>
      <button type="button" id="overlayToggleBtn" class="upload-btn">
        <span id="overlayBtnText">
          <i class="bi bi-camera-fill"></i> Ch·ªçn ·∫£nh
        </span>
      </button>

      <input id="overlayInput" type="file" accept="image/*" style="display:none" />
      <div class="upload-hint">PNG/JPG ‚Ä¢ S·∫Ω t·ª± cƒÉn v√†o khung ·∫£nh ƒë√£ thi·∫øt k·∫ø.</div>
    </div>

    <!-- Crop/Pan Controls -->
    <div id="cropControls" style="display:none; border-top:1px solid var(--border-soft); padding-top:12px; gap:8px; display:flex; flex-direction:column;">
      <div class="row">
        <div style="flex:1">
          <label>Zoom ·∫£nh (<span id="zoomImageLabel">100</span>%)</label>
          <input id="imageZoom" type="range" min="50" max="200" step="10" value="100" />
        </div>
      </div>
      <button type="button" id="resetImageBtn" class="btn" style="margin:0; width:100%; font-size:11px; padding:6px 10px;">
        <i class="bi bi-arrow-counterclockwise"></i> ƒê·∫∑t l·∫°i
      </button>
      <div style="font-size:11px; color:#7a5c4b; text-align:center;">
        üí° K√©o ·∫£nh tr√™n khung ƒë·ªÉ ƒëi·ªÅu ch·ªânh v·ªã tr√≠
      </div>
    </div>

    <button
      class="btn"
      id="downloadBtn"
      style="
        font-family:-apple-system,'Segoe UI',Tahoma,'Helvetica Neue',Arial,'DejaVu Sans',Ubuntu,Cantarell,'Noto Sans',sans-serif;
        font-weight:700; letter-spacing:.02em;
        display:block;
        margin:8px auto 0;
        text-align:center;
        align-self:center;
      "
    >
      <i class="bi bi-download"></i> Xu·∫•t ·∫£nh PNG
    </button>

  </div>

  <div class="main">
    <div class="canvas-wrap">
      <canvas id="canvas" width="1080" height="1080"></canvas>
    </div>
  </div>

<script>
  // ================= CONFIG =================
  const API_BASE = "/api/frame-layout"; // relative: ch·∫°y ƒë∆∞·ª£c c·∫£ localhost & ngrok
  const BASE_SIZE = 1080;
  const DEFAULT_OVERLAY_RADIUS = 20;
  const DEFAULT_OVERLAY_ALPHA = 1;
  const FIT_MODE = "cover";
  const FONT_FAMILY = "Montserrat, system-ui, -apple-system, sans-serif";

  // ================= DOM =================
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");

  const frameSelect = document.getElementById("frameSelect");
  const statusText = document.getElementById("statusText");

  const lineHeightEl = document.getElementById("lineHeight");
  const paddingEl = document.getElementById("padding");
  const exportSizeEl = document.getElementById("exportSize");
  const previewZoomEl = document.getElementById("previewZoom");
  const zoomLabel = document.getElementById("zoomLabel");

  const overlayInput = document.getElementById("overlayInput");
  const overlayToggleBtn = document.getElementById("overlayToggleBtn");
  const overlayBtnText = document.getElementById("overlayBtnText");

  const downloadBtn = document.getElementById("downloadBtn");
  const FRAME_DEFAULT_COLORS = {
    "new__default1": "m√†u ƒë·ªè",
    "new__default": "m√†u x√°m",
    "my_frame4": "xanh l√° c√¢y",
    "my_frame3": "xanh navy",
    "my_frame5": "m√†u tr·∫Øng",
  };

  const templateInputs = document.querySelectorAll("[data-template-input]");
  const templateFieldMap = {
    busy: document.getElementById("templateBusy"),
    highlight: document.getElementById("templateHighlight"),
    sometimes: document.getElementById("templateSometimes"),
    unique: document.getElementById("templateUnique"),
    threeWords: document.getElementById("templateThreeWords"),
    color: document.getElementById("templateColor"),
    answer: document.getElementById("templateAnswer"),
  };

  const pageParams = new URLSearchParams(window.location.search);
  const presetColor = pageParams.get("color") || "";
  if (presetColor && templateFieldMap.color && !templateFieldMap.color.value) {
    templateFieldMap.color.value = presetColor;
  }
  templateInputs.forEach((input) => {
    safeAddListener(input, "input", sizeChange);
  });

  const imageZoomEl = document.getElementById("imageZoom");
  const zoomImageLabel = document.getElementById("zoomImageLabel");
  const cropControls = document.getElementById("cropControls");
  const resetImageBtn = document.getElementById("resetImageBtn");

  // ================= STATE =================
  let frames = [];
  let currentKey = null;
  let currentLayout = null; // { frame_url, textBox, imageBox, colors... }

  let frameImg = new Image();
  let frameLoaded = false;
  let layoutLoaded = false;

  let overlayImg = null;
  let hasOverlay = false;
  // --- Tr·∫°ng th√°i ·∫£nh Overlay ---
  let overlayZoom = 1.0;
  let overlayOffsetX = 0;
  let overlayOffsetY = 0;

  // ================= HELPERS =================
  function setStatus(msg, error = false) {
    if (!statusText) return;
    statusText.textContent = msg;
    statusText.style.color = error ? "#f97316" : "#6b7280";
  }

  function safeAddListener(el, ev, fn) {
    if (el) el.addEventListener(ev, fn);
  }

  function boxPercentToPx(box, size) {
    return {
      x: (box.x / 100) * size,
      y: (box.y / 100) * size,
      w: (box.w / 100) * size,
      h: (box.h / 100) * size,
    };
  }

  // ===== Template Text Helpers =====
  const TEMPLATE_BLANK = "__________________";

  function readTemplateField(field) {
    if (!field) return "";
    return (field.value || "").trim();
  }

  function getTemplateValues() {
    return {
      busy: readTemplateField(templateFieldMap.busy),
      highlight: readTemplateField(templateFieldMap.highlight),
      sometimes: readTemplateField(templateFieldMap.sometimes),
      unique: readTemplateField(templateFieldMap.unique),
      threeWords: readTemplateField(templateFieldMap.threeWords),
      color: readTemplateField(templateFieldMap.color),
      answer: readTemplateField(templateFieldMap.answer),
    };
  }

  function createValueSegment(value) {
    const text = value || TEMPLATE_BLANK;
    return {
      text,
      bold: true,
    };
  }

  function buildTemplateLineSegments() {
    const values = getTemplateValues();
    return [
      [
        { text: 'H√¥m nay t√¥i ‚Äúb·∫≠n‚Äù ki·ªÉu ', bold: false },
        createValueSegment(values.busy),
      ],
      [
        { text: 'T√≠nh c√°ch - c·∫£m x√∫c ƒë√≥ th·ªÉ hi·ªán r√µ nh·∫•t khi ', bold: false },
        createValueSegment(values.highlight),
      ],
      [
        { text: 'Tuy ƒë√¥i khi t√¥i th·∫•y m√¨nh ', bold: false },
        createValueSegment(values.sometimes),
        { text: ' nh∆∞ng ƒë√≥ v·∫´n l√† t√¥i.', bold: false },
      ],
      [
        { text: 'T√¥i nghƒ© ƒëi·ªÅu khi·∫øn t√¥i kh√°c bi·ªát l√† ', bold: false },
        createValueSegment(values.unique),
      ],
      [
        {
          text: 'ƒê·ªÉ m√¥ t·∫£ t√≠nh c√°ch - c·∫£m x√∫c ƒë√≥ v·ªõi 3 t·ª´ kh√°c nhau th√¨ s·∫Ω l√† ',
          bold: false,
        },
        createValueSegment(values.threeWords),
      ],
      [
        {
          text: 'B·∫°n th·∫•y ',
          bold: false,
        },
        createValueSegment(values.color),
        {
          text: ' c√≥ b·ªôc l·ªô v√† th·ªÉ hi·ªán ƒë∆∞·ª£c t√≠nh c√°ch - c·∫£m x√∫c ch√≠nh c·ªßa b·∫°n?',
          bold: false,
        }
      ],
      [
        {
          text: values.answer,
          bold: true,
        }
      ]
    ];
  }

  function buildTemplateRenderData() {
    const lineSegments = buildTemplateLineSegments();
    let text = '';
    const styles = [];

    lineSegments.forEach((line, idx) => {
      line.forEach((segment) => {
        if (!segment.text) return;
        text += segment.text;
        for (let i = 0; i < segment.text.length; i++) {
          styles.push(!!segment.bold);
        }
      });

      if (idx < lineSegments.length - 1) {
        text += '\n';
        styles.push(false);
      }
    });

    return { text, styles };
  }

  function getTemplatePlainText() {
    return buildTemplateRenderData().text;
  }

  function getEditorAlign() {
    return "left";
  }

  function getEditorPlainText() {
    return getTemplatePlainText();
  }

  // ===== Wrap & fit =====
  function wrapLines(ctx, text, maxWidth) {
    const lines = [];
    const paragraphs = text.split("\n");

    for (const para of paragraphs) {
      if (para === "") {
        lines.push("");
        continue;
      }
      const words = para.split(/\s+/);
      let line = "";
      for (const w of words) {
        if (!w) continue;
        const test = line ? line + " " + w : w;
        if (ctx.measureText(test).width <= maxWidth) {
          line = test;
        } else {
          if (line) lines.push(line);
          line = w;
        }
      }
      if (line) lines.push(line);
    }
    return lines;
  }

  function computeFittedLines(text, boxPx, padding, lineH, styleFlags) {
    const START_FONT = 20;
    const MIN_FONT = 14;
    let fontPx = START_FONT;
    const maxHeight = boxPx.h - padding * 2;
    let lines = [];

    while (fontPx >= MIN_FONT) {
      ctx.font = `normal 400 ${fontPx}px ${FONT_FAMILY}`;
      const maxWidth = Math.max(0, boxPx.w - padding * 2);
      lines = wrapLines(ctx, text, maxWidth);

      const lh = lineH * fontPx;
      const totalH = lines.length * lh;

      if (totalH <= maxHeight) {
        return { fontPx, lines, lh };
      }
      fontPx--;
    }

    ctx.font = `normal 400 ${MIN_FONT}px ${FONT_FAMILY}`;
    const maxWidth = Math.max(0, boxPx.w - padding * 2);
    lines = wrapStyledLines(ctx, text, styleFlags, maxWidth, MIN_FONT);
    return { fontPx: MIN_FONT, lines, lh: lineH * MIN_FONT };
  }

  function drawRoundedRectPath(ctx, x, y, w, h, r) {
    const rr = Math.min(r, w / 2, h / 2);
    ctx.beginPath();
    ctx.moveTo(x + rr, y);
    ctx.arcTo(x + w, y, x + w, y + h, rr);
    ctx.arcTo(x + w, y + h, x, y + h, rr);
    ctx.arcTo(x, y + h, x, y, rr);
    ctx.arcTo(x, y, x + w, y, rr);
    ctx.closePath();
  }

  function updateOverlayButton() {
    if (!overlayToggleBtn || !overlayBtnText) return;

    if (hasOverlay) {
      overlayBtnText.innerHTML = '<i class="bi bi-x-lg"></i> G·ª° ·∫£nh';
      overlayToggleBtn.style.background = "linear-gradient(180deg, var(--brand-red), var(--brand-red-700))";
      overlayToggleBtn.style.color = "#fff";
      
      if (cropControls) cropControls.style.display = "block";
    } else {
      overlayBtnText.innerHTML = '<i class="bi bi-camera-fill"></i> Ch·ªçn ·∫£nh';
      overlayToggleBtn.style.background = "var(--brand-beige-50)";
      overlayToggleBtn.style.color = "var(--brand-red-900)";
      
      if (cropControls) cropControls.style.display = "none";
    }
  }

  // ================= RENDER =================
  function render(targetSize = BASE_SIZE, opts = {}) {
    if (!frameLoaded || !layoutLoaded || !currentLayout) return;

    const { forceHideBox = false } = opts;

    const textColor      = currentLayout.textColor        || "#333333";
    const imgBorderColor = currentLayout.imageBorderColor || "#000000";
    const textBoxColor   = currentLayout.textBoxColor     || "#22c55e";
    const imageBoxColor  = currentLayout.imageBoxColor    || "#38bdf8";

    const DPR = window.devicePixelRatio || 1;
    canvas.width = targetSize * DPR;
    canvas.height = targetSize * DPR;

    const zoom = parseInt(previewZoomEl?.value || "70", 10) / 100;
    canvas.style.width = targetSize * zoom + "px";
    canvas.style.height = "auto";

    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    ctx.clearRect(0, 0, targetSize, targetSize);

    // V·∫Ω frame (cover)
    const ir = frameImg.width / frameImg.height || 1;
    let w, h, x, y;
    if (ir > 1) {
      h = targetSize;
      w = h * ir;
      x = -(w - targetSize) / 2;
      y = 0;
    } else {
      w = targetSize;
      h = w / ir;
      x = 0;
      y = -(h - targetSize) / 2;
    }
    ctx.drawImage(frameImg, x, y, w, h);

    const textPx = boxPercentToPx(currentLayout.textBox, targetSize);
    const imagePx = boxPercentToPx(currentLayout.imageBox, targetSize);

    // ·∫¢nh overlay trong khung
    const rad = DEFAULT_OVERLAY_RADIUS;

    ctx.save();
    drawRoundedRectPath(ctx, imagePx.x, imagePx.y, imagePx.w, imagePx.h, rad);
    ctx.clip();

    // n·ªÅn tr·∫Øng m·∫∑c ƒë·ªãnh
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(imagePx.x, imagePx.y, imagePx.w, imagePx.h);

    if (overlayImg && hasOverlay) {
      const ir2 = overlayImg.width / overlayImg.height;
      const br = imagePx.w / imagePx.h;
      let initialW, initialH, initialX, initialY;

      if (ir2 > br) {
        initialH = imagePx.h;
        initialW = initialH * ir2;
        initialX = imagePx.x - (initialW - imagePx.w) / 2;
        initialY = imagePx.y;
      } else {
        initialW = imagePx.w;
        initialH = initialW / ir2;
        initialX = imagePx.x;
        initialY = imagePx.y - (initialH - imagePx.h) / 2;
      }

      const zoomedW = initialW * overlayZoom;
      const zoomedH = initialH * overlayZoom;
      const zoomCenterX = initialX + initialW / 2;
      const zoomCenterY = initialY + initialH / 2;

      const drawX = zoomCenterX - zoomedW / 2 + overlayOffsetX;
      const drawY = zoomCenterY - zoomedH / 2 + overlayOffsetY;

      ctx.globalAlpha = DEFAULT_OVERLAY_ALPHA;
      ctx.drawImage(overlayImg, drawX, drawY, zoomedW, zoomedH);
    }

    ctx.restore();

    // vi·ªÅn khung ·∫£nh
    ctx.save();
    drawRoundedRectPath(ctx, imagePx.x, imagePx.y, imagePx.w, imagePx.h, rad);
    ctx.lineWidth = 6;
    ctx.strokeStyle = imgBorderColor;
    ctx.stroke();
    ctx.restore();

    // KHUNG DEBUG (t·∫Øt m·∫∑c ƒë·ªãnh)
    const showNow = false;
    if (showNow && !forceHideBox) {
      ctx.save();
      ctx.setLineDash([8, 6]);
      ctx.lineWidth = 2.5;

      ctx.strokeStyle = textBoxColor;
      ctx.strokeRect(textPx.x, textPx.y, textPx.w, textPx.h);

      ctx.strokeStyle = imageBoxColor;
      ctx.strokeRect(imagePx.x, imagePx.y, imagePx.w, imagePx.h);

      ctx.setLineDash([]);
      ctx.restore();
    }

    // ===== V·∫Ω text =====
    const padding = parseFloat(paddingEl?.value) || 0;

    let rawLH = parseFloat(lineHeightEl?.value);
    if (isNaN(rawLH)) rawLH = 1.0;
    const lineH = Math.max(0.8, rawLH);

    const renderData = buildTemplateRenderData();
    const plain = renderData.text;
    const styleFlags = renderData.styles;
    const fit = computeFittedLines(plain, textPx, padding, lineH, styleFlags);

    ctx.textBaseline = "top";
    const resolvedTextColor = currentLayout.textColor || currentLayout.imageBorderColor || "#333";
    ctx.fillStyle = resolvedTextColor;

    const innerLeft = textPx.x + padding;
    const innerRight = textPx.x + textPx.w - padding;
    const innerWidth = innerRight - innerLeft;

    ctx.save();
    ctx.beginPath();

    // Th√™m margin 2px ƒë·ªÉ tr√°nh c·∫Øt ch·ªØ
    ctx.rect(
      textPx.x - 2,
      textPx.y - 2,
      textPx.w + 4,
      textPx.h + 4
    );

    ctx.clip();

    let ty = textPx.y + padding;
    const align = getEditorAlign();
    let styleIndex = 0;
    const skipNewlines = () => {
      while (styleIndex < plain.length && plain[styleIndex] === "\n") {
        styleIndex++;
      }
    };

    skipNewlines();

    for (const line of fit.lines) {
      const lineText = line || "";

      // T√°ch segment theo style th·ª±c c·ªßa t·ª´ng k√Ω t·ª±
      const segments = [];
      let currentBold = styleFlags[styleIndex];
      let currentText = lineText[0] || "";

      for (let i = 1; i < lineText.length; i++) {
        const isBold = styleFlags[styleIndex + i];
        if (isBold === currentBold) {
          currentText += lineText[i];
        } else {
          segments.push({ text: currentText, bold: currentBold });
          currentBold = isBold;
          currentText = lineText[i];
        }
      }
      segments.push({ text: currentText, bold: currentBold });

      // ƒëo width t·ª´ng segment
      let total = 0;
      const measured = segments.map(seg => {
        ctx.font = `${seg.bold ? "600" : "400"} ${fit.fontPx}px ${FONT_FAMILY}`;
        const w = ctx.measureText(seg.text).width;
        total += w;
        return { ...seg, width: w };
      });

      // T√≠nh v·ªã tr√≠ render theo align
      let x = innerLeft;
      if (align === "center") x = innerLeft + (innerWidth - total) / 2;
      if (align === "right") x = innerRight - total;

      // V·∫Ω t·ª´ng segment
      measured.forEach(seg => {
        ctx.font = `${seg.bold ? "600" : "400"} ${fit.fontPx}px ${FONT_FAMILY}`;
        ctx.fillText(seg.text, x, ty);
        x += seg.width;
      });

      // Update index & d√≤ng
      styleIndex += lineText.length + 1; 
      ty += fit.lh;
    }

    ctx.restore();
  }

  // ===== H·ªó tr·ª£ wrap theo style (d√πng khi text qu√° d√†i) =====
  function measureStyledWidth(text, styleFlags, startIndex, fontPx) {
    let width = 0;
    for (let i = 0; i < text.length; i++) {
      const isBold = styleFlags[startIndex + i];
      ctx.font = `${isBold ? "600" : "400"} ${fontPx}px ${FONT_FAMILY}`;
      width += ctx.measureText(text[i]).width;
    }
    return width;
  }

  function wrapStyledLines(ctx, text, styleFlags, maxWidth, fontPx) {
    const lines = [];
    const paragraphs = text.split("\n");
    let styleIndex = 0;

    for (const para of paragraphs) {
      if (para === "") {
        lines.push("");
        styleIndex++;
        continue;
      }

      const words = para.split(/\s+/);
      let line = "";

      for (const w of words) {
        if (!w) continue;

        const test = line ? line + " " + w : w;
        const testWidth = measureStyledWidth(test, styleFlags, styleIndex, fontPx);

        if (testWidth <= maxWidth) {
          line = test;
        } else {
          if (line) lines.push(line);
          line = w;
        }

        // di chuy·ªÉn styleIndex theo s·ªë k√Ω t·ª± ƒë√£ ki·ªÉm tra
        styleIndex += w.length + 1;
      }

      if (line) lines.push(line);
    }

    return lines;
  }

  // ================= LOAD FRAMES FROM API =================
  const FRAME_API_BASE = "/api/frame-layout";
  const TEMPLATE_API_BASE = "/api/templates";

  async function loadFrameList() {
    const params = new URLSearchParams(window.location.search);
    const tplKey = params.get("tpl");             // template ƒë∆∞·ª£c ch·ªçn (n·∫øu c√≥)
    const frameKeyFromUrl = params.get("frame");  // optional: deep-link frame

    try {
      if (tplKey) {
        setStatus(`ƒêang t·∫£i frame c·ªßa template "${tplKey}"...`);
        const res = await fetch(`${TEMPLATE_API_BASE}/${encodeURIComponent(tplKey)}`);
        if (!res.ok) throw new Error("HTTP " + res.status);
        const data = await res.json();

        if (!data.frames || !data.frames.length) {
          setStatus("Template n√†y ch∆∞a c√≥ frame n√†o. H√£y c·∫•u h√¨nh frame_layouts v·ªõi template_id t∆∞∆°ng ·ª©ng.", true);
          frameSelect.innerHTML = "";
          return;
        }

        frames = data.frames; // [{layout_key, frame_url}, ...]
        frameSelect.innerHTML = "";
        frames.forEach(f => {
          const opt = document.createElement("option");
          opt.value = f.layout_key;
          opt.textContent = f.layout_key;
          frameSelect.appendChild(opt);
        });

        const initialKey = (frameKeyFromUrl && frames.some(f => f.layout_key === frameKeyFromUrl))
          ? frameKeyFromUrl
          : frames[0].layout_key;

        currentKey = initialKey;
        frameSelect.value = currentKey;

        await loadLayout(currentKey);
        setStatus(`Template: ${data.name || tplKey} ‚Ä¢ ƒêang d√πng frame "${currentKey}"`);
        return;
      }

      // Fallback: l·∫•y t·∫•t c·∫£ frame
      setStatus("ƒêang t·∫£i danh s√°ch frame...");

      const res = await fetch(FRAME_API_BASE);
      if (!res.ok) throw new Error("HTTP " + res.status);
      const list = await res.json();

      if (!list.length) {
        setStatus("Ch∆∞a c√≥ frame n√†o trong h·ªá th·ªëng.", true);
        frameSelect.innerHTML = "";
        return;
      }

      frames = list; // [{layout_key, ...}, ...]
      frameSelect.innerHTML = "";
      frames.forEach(f => {
        const opt = document.createElement("option");
        opt.value = f.layout_key;
        opt.textContent = f.layout_key;
        frameSelect.appendChild(opt);
      });

      const initialKey = (frameKeyFromUrl && frames.some(f => f.layout_key === frameKeyFromUrl))
        ? frameKeyFromUrl
        : frames[0].layout_key;

      currentKey = initialKey;
      frameSelect.value = currentKey;

      await loadLayout(currentKey);
      setStatus(`ƒêang d√πng frame "${currentKey}"`);
    } catch (err) {
      console.error(err);
      setStatus("Kh√¥ng load ƒë∆∞·ª£c danh s√°ch frame.", true);
    }
  }

  async function loadLayout(key) {
    layoutLoaded = false;
    frameLoaded = false;
    overlayImg = null;
    hasOverlay = false;

    if (overlayInput) overlayInput.value = "";
    updateOverlayButton();

    // --- Reset tr·∫°ng th√°i Overlay ---
    overlayZoom = 1.0;
    overlayOffsetX = 0;
    overlayOffsetY = 0;
    if (imageZoomEl) {
      imageZoomEl.value = 100;
      if (zoomImageLabel) zoomImageLabel.textContent = "100";
    }

    setStatus("ƒêang t·∫£i layout " + key + "...");
    try {
      const res = await fetch(`/api/frame-layout/${encodeURIComponent(key)}`);
      if (!res.ok) throw new Error("HTTP " + res.status);
      const data = await res.json();

      currentLayout = {
        frame_url: data.frame_url,
        textBox: data.textBox,
        imageBox: data.imageBox,
        textColor: data.textColor || "#333333",
        imageBorderColor: data.imageBorderColor || "#000000",
        textBoxColor: data.textBoxColor || "#22c55e",
        imageBoxColor: data.imageBoxColor || "#38bdf8",
      };

      const mappedColor = FRAME_DEFAULT_COLORS[key];
      if (mappedColor && templateFieldMap.color) {
        templateFieldMap.color.value = mappedColor;
      }

      await loadFrameImage(currentLayout.frame_url);
      layoutLoaded = true;
      setStatus(`ƒê√£ t·∫£i frame "${key}". Nh·∫≠p n·ªôi dung & ch·ªçn ·∫£nh.`);
      sizeChange();
    } catch (err) {
      console.error(err);
      setStatus("Kh√¥ng load ƒë∆∞·ª£c layout/frame.", true);
    }
  }

  function loadFrameImage(url) {
    return new Promise((resolve) => {
      frameImg = new Image();
      frameImg.onload = () => {
        frameLoaded = true;
        resolve();
      };
      frameImg.onerror = () => {
        setStatus("Kh√¥ng load ƒë∆∞·ª£c frame_url: " + url, true);
        resolve();
      };
      frameImg.src = url;
    });
  }

  // ================= EVENTS =================
  // ch·ªçn frame kh√°c
  safeAddListener(frameSelect, "change", async () => {
    const key = frameSelect.value;
    if (!key) return;
    currentKey = key;
    await loadLayout(currentKey);
    sizeChange();
  });

  // auto render khi thay ƒë·ªïi text / lineHeight / padding / exportSize
  ["input", "change"].forEach((ev) => {
    safeAddListener(lineHeightEl, ev, sizeChange);
    safeAddListener(paddingEl, ev, sizeChange);
    safeAddListener(exportSizeEl, ev, sizeChange);
  });

  // zoom preview
  if (previewZoomEl && zoomLabel) {
    const handleZoom = () => {
      zoomLabel.textContent = previewZoomEl.value;
      sizeChange();
    };
    previewZoomEl.addEventListener("input", handleZoom);
    previewZoomEl.addEventListener("change", handleZoom);
  }

  // zoom image overlay
  if (imageZoomEl && zoomImageLabel) {
    const handleImageZoom = () => {
      const zoomPercent = parseInt(imageZoomEl.value, 10);
      zoomImageLabel.textContent = zoomPercent;
      overlayZoom = zoomPercent / 100;
      clampImageOffset();
      sizeChange();
    };
    imageZoomEl.addEventListener("input", handleImageZoom);
    imageZoomEl.addEventListener("change", handleImageZoom);
  }

  // n√∫t reset ·∫£nh
  safeAddListener(resetImageBtn, "click", () => {
    if (imageZoomEl) {
      imageZoomEl.value = 100;
      overlayZoom = 1.0;
      if (zoomImageLabel) zoomImageLabel.textContent = "100";
    }
    overlayOffsetX = 0;
    overlayOffsetY = 0;
    sizeChange();
  });

  // n√∫t ch·ªçn / g·ª° ·∫£nh
  safeAddListener(overlayToggleBtn, "click", () => {
    if (hasOverlay) {
      overlayImg = null;
      hasOverlay = false;
      if (overlayInput) overlayInput.value = "";
      updateOverlayButton();
      sizeChange();
    } else {
      if (overlayInput) overlayInput.click();
    }
  });

  // upload ·∫£nh overlay
  safeAddListener(overlayInput, "change", (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = () => {
      const img = new Image();
      img.onload = () => {
        overlayImg = img;
        hasOverlay = true;
        overlayOffsetX = 0;
        overlayOffsetY = 0;
        updateOverlayButton();
        sizeChange();
      };
      img.src = reader.result;
    };
    reader.readAsDataURL(file);
  });

  // ================= DRAG TO PAN IMAGE =================
  let isDragging = false;
  let dragStartX = 0;
  let dragStartY = 0;
  let dragStartOffsetX = 0;
  let dragStartOffsetY = 0;

  function clampImageOffset(targetSize = BASE_SIZE) {
    if (!overlayImg || !currentLayout) return;

    const imagePx = boxPercentToPx(currentLayout.imageBox, targetSize);
    const ir2 = overlayImg.width / overlayImg.height;
    const br = imagePx.w / imagePx.h;
    
    let initialW, initialH;
    if (ir2 > br) {
      initialH = imagePx.h;
      initialW = initialH * ir2;
    } else {
      initialW = imagePx.w;
      initialH = initialW / ir2;
    }

    const zoomedW = initialW * overlayZoom;
    const zoomedH = initialH * overlayZoom;

    let minOffsetX, maxOffsetX;
    if (zoomedW > imagePx.w) {
      maxOffsetX = (zoomedW - imagePx.w) / 2;
      minOffsetX = -maxOffsetX;
    } else {
      minOffsetX = 0;
      maxOffsetX = 0;
    }

    let minOffsetY, maxOffsetY;
    if (zoomedH > imagePx.h) {
      maxOffsetY = (zoomedH - imagePx.h) / 2;
      minOffsetY = -maxOffsetY;
    } else {
      minOffsetY = 0;
      maxOffsetY = 0;
    }

    overlayOffsetX = Math.max(minOffsetX, Math.min(maxOffsetX, overlayOffsetX));
    overlayOffsetY = Math.max(minOffsetY, Math.min(maxOffsetY, overlayOffsetY));
  }

  function getEventCoords(e) {
    if (e.touches && e.touches.length > 0) {
      return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    }
    return { x: e.clientX, y: e.clientY };
  }

  const canvasWrap = document.querySelector('.canvas-wrap');
  if (canvasWrap) {
    // Mouse events (desktop)
    canvasWrap.addEventListener('mousedown', (e) => {
      if (!hasOverlay || !currentLayout) return;
      
      isDragging = true;
      const coords = getEventCoords(e);
      dragStartX = coords.x;
      dragStartY = coords.y;
      dragStartOffsetX = overlayOffsetX;
      dragStartOffsetY = overlayOffsetY;
      canvasWrap.style.cursor = 'grabbing';
      e.preventDefault();
    });

    function calculateScale() {
      const previewZoom = parseInt(previewZoomEl?.value || "70", 10) / 100;
      const canvasRect = canvas.getBoundingClientRect();
      const canvasDisplayWidth = canvasRect.width || (520 * previewZoom);
      return BASE_SIZE / canvasDisplayWidth;
    }

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;

      const scale = calculateScale();
      const coords = getEventCoords(e);
      const deltaX = (coords.x - dragStartX) * scale;
      const deltaY = (coords.y - dragStartY) * scale;

      overlayOffsetX = dragStartOffsetX + deltaX;
      overlayOffsetY = dragStartOffsetY + deltaY;

      clampImageOffset();
      sizeChange();
    });

    document.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        canvasWrap.style.cursor = 'grab';
      }
    });

    // Touch events (mobile)
    canvasWrap.addEventListener('touchstart', (e) => {
      if (!hasOverlay || !currentLayout) return;
      if (e.touches.length !== 1) return;
      
      isDragging = true;
      const coords = getEventCoords(e);
      dragStartX = coords.x;
      dragStartY = coords.y;
      dragStartOffsetX = overlayOffsetX;
      dragStartOffsetY = overlayOffsetY;
      e.preventDefault();
    }, { passive: false });

    canvasWrap.addEventListener('touchmove', (e) => {
      if (!isDragging || !hasOverlay) return;
      if (e.touches.length !== 1) return;

      const scale = calculateScale();
      const coords = getEventCoords(e);
      const deltaX = (coords.x - dragStartX) * scale;
      const deltaY = (coords.y - dragStartY) * scale;

      overlayOffsetX = dragStartOffsetX + deltaX;
      overlayOffsetY = dragStartOffsetY + deltaY;

      clampImageOffset();
      sizeChange();
      e.preventDefault();
    }, { passive: false });

    canvasWrap.addEventListener('touchend', () => {
      if (isDragging) {
        isDragging = false;
      }
    });

    canvasWrap.addEventListener('touchcancel', () => {
      if (isDragging) {
        isDragging = false;
      }
    });

    // Mouse hover effects (ch·ªâ desktop)
    canvasWrap.addEventListener('mouseenter', () => {
      if (hasOverlay && !isDragging) {
        canvasWrap.style.cursor = 'grab';
      }
    });

    canvasWrap.addEventListener('mouseleave', () => {
      canvasWrap.style.cursor = 'default';
    });
  }

  // download: desktop t·∫£i file, mobile/in-app m·ªü JPEG ƒë·ªÉ gi·ªØ-l∆∞u
  safeAddListener(downloadBtn, "click", () => {
    if (!frameLoaded || !layoutLoaded || !currentLayout) return;

    const size = parseInt(exportSizeEl?.value || "1080", 10);
    const fileName = `${currentKey || "frame"}_export.jpg`;

    // v·∫Ω b·∫£n s·∫°ch
    render(size, { forceHideBox: true });

    const ua = navigator.userAgent || "";
    const isIOS    = /iP(hone|od|ad)/i.test(ua);
    const isSafari = /^((?!chrome|android).)*safari/i.test(ua);
    const isInApp  = /(FBAN|FBAV|FB_IAB|FB4A|Instagram|Messenger)/i.test(ua);

    const dataUrlJpeg = canvas.toDataURL("image/jpeg", 0.92);

    if (isInApp) {
      const html =
        '<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width,initial-scale=1">' +
        '<title>L∆∞u ·∫£nh</title></head>' +
        '<body style="margin:0;background:#000;display:flex;align-items:center;justify-content:center;">' +
        '<img src="' + dataUrlJpeg + '" style="max-width:100%;height:auto;display:block;" />' +
        '</body></html>';

      const win = window.open();
      if (win) {
        win.document.open();
        win.document.write(html);
        win.document.close();
      } else {
        document.open();
        document.write(html);
        document.close();
      }
      sizeChange();
      return;
    }

    if (isIOS && isSafari) {
      const win = window.open();
      if (win) {
        win.document.open();
        win.document.write(
          '<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width,initial-scale=1">' +
          '<title>L∆∞u ·∫£nh</title></head>' +
          '<body style="margin:0;background:#000;display:flex;align-items:center;justify-content:center;">' +
          '<img src="' + dataUrlJpeg + '" style="max-width:100%;height:auto;display:block;" />' +
          '</body></html>'
        );
        win.document.close();
      } else {
        window.location.href = dataUrlJpeg;
      }
      sizeChange();
      return;
    }

    canvas.toBlob((blob) => {
      if (!blob) return;
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      sizeChange();
    });
  });

  // ================= INIT =================
  function sizeChange() {
    render(BASE_SIZE);
  }

  (async function init() {
    updateOverlayButton();
    setStatus("ƒêang t·∫£i danh s√°ch frame...");
    await loadFrameList();

    if (document.fonts && document.fonts.ready) {
      document.fonts.ready.then(sizeChange);
    } else {
      sizeChange();
    }

    window.addEventListener("resize", sizeChange);
  })();
</script>
</body>
</html>
